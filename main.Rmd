---
title: "Inter-generational conflict and the declining labor share"
output: 
  github_document:
    fig_width: 7
always_allow_html: true
bibliography: referencesLISA.bib
---

# Initialization

I start loading the initial script.

```{r init, echo = F}
# Load init script
source("_script/init.R")
# knitr options
knitr::opts_chunk$set(warning = FALSE)
# Function to round in solver
ceiling_digit = function(x, level=1) round(x+ 5*10^(-level-1), level)
flooring_digit = function(x, level=1) round(x - 5*10^(-level-1), level)
# Country set
CountrySet = c("France", "United States")
# List
list.graph = list()
```

Then, I load the data. For more details on data sources, see the `README.md` file in `_data/_raw/`. For more details on data treatment and the construction of these datasets, see the scripts in `_script/_treatment/`.

```{r data-load}
# Penn World Table 9.1
pwt = read.csv(file.path(loc_data, "_final", "pwt.csv"))
# OECD data
oecd = read.csv(file.path(loc_data, "_final", "oecd.csv"))
# Demographic data
demo = read.csv(file.path(loc_data, "_final", "demo.csv"))
# United Nations: World Population Prospects
wpp = read.csv(file.path(loc_data, "_final", "wpp.csv"))
# CWED data
cwed = read.csv(file.path(loc_data, "_final", "cwed.csv"))
## Merge
df = merge(pwt, oecd, all = TRUE) %>% merge(demo, all = TRUE) %>% merge(cwed, all = TRUE) %>%  
  subset(Year >= 1970)
```

# Empirics

### Labor share

Figure \@ref(fig:emp-ls) displays the labor share since 1970 for Australia, France, Japan and the United States. Self-employed income is considered as mixed income. The labor share has been declining in these countries.

```{r emp-ls, fig.cap="Labor share in OECD countries", fig.show="hide", warning=F}
df %>% 
  subset(Year %in% c(1970:2017)) %>% 
  select(Country, Year, lab_sh1, i_lab_sh1) %>% 
  subset(Country %in% c("Australia", "France", "Japan", "United States")) %>%
  mutate(lab_sh1 = ifelse(i_lab_sh1 == 1, lab_sh1, NA)) %>% # Remove interpolated labor share by the PWT
  
  ggplot(aes(x = Year, y = lab_sh1)) +
  geom_line(aes(color = Country)) +
  scale_color_brewer(palette = "Set1") +
  labs(x = element_blank(), y = element_blank(), title = "Labor share", color = element_blank()) +
  theme_bw() +
  theme(legend.position = "bottom") +
  ggsave(file.path(loc_graphic, "emp-ls-color.png"), width = 7, height = 7/1.5)
```

```{r emp-ls-show, fig.cap="Labor share in OECD countries"}
include_graphics(file.path(loc_graphic, "emp-ls-color.png"))
```

Figure \@ref(fig:emp-lsadj) presents the labor share data on the same sample of countries over the same period with different adjustment methods for self-employed income from the PWT. For a discussion of adjusment methods, see @Gollin2002Getting. For more details on adjustment methods in the PWT, see @Feenstra2015Next. The labor share from the OECD data is also plotted. Although the magnitude changes according to the adjustment method and the data source, the dynamics remain roughly similar. 

```{r emp-lsadj, fig.cap="Labor share in OECD countries with different adjustment methods"}
## Penn World Table : all adjustment methods for the labor share
df %>% 
  subset(Year %in% c(1970:2017)) %>% 
  select(Country, Year, lab_sh1, i_lab_sh1, lab_sh2, i_lab_sh2,
         lab_sh3, i_lab_sh3, lab_sh4, i_lab_sh4, labor_share) %>% 
  subset(Country %in% c("Australia", "France", "Japan", "United States")) %>%
  mutate(lab_sh1 = ifelse(i_lab_sh1 == 1, lab_sh1, NA),
         lab_sh2 = ifelse(i_lab_sh2 == 1, lab_sh2, NA),
         lab_sh3 = ifelse(i_lab_sh3 == 1, lab_sh3, NA),
         lab_sh4 = ifelse(i_lab_sh4 == 1, lab_sh4, NA),) %>% # Remove interpolated
  select(-starts_with("i_lab")) %>% 
  setDT %>% melt(id.vars = c("Country", "Year"), variable.name = "adjustment") %>% 
  # subset(Country == "France") %>% 
  mutate(oecd = if_else(adjustment == "labor_share", "OECD", "PWT") %>% 
           factor(levels = c("PWT", "OECD"))) %>% 
  mutate(adjustment = factor(adjustment,
    labels = c("Mixed income", "Part mixed income",
               "Average wage", "Agriculture", "OECD"))) %>% 
  
  ggplot(aes(x = Year, y = value)) +
  geom_line(aes(color = adjustment, linetype = oecd)) +
  facet_wrap(Country ~ .) +
  scale_color_manual(values = c(brewer.pal(8, "Set1")[c(1:4)], "black")) +
  labs(x = element_blank(), y = "Labor share", title = element_blank(),
       color = "Adjustment method", linetype = "Data") +
  theme_bw() +
  theme(legend.position = "right") +
  ggsave(file.path(loc_graphic, "emp-lsadj-color.png"), width = 7, height = 7/1.5)

```



```{r emp-ls, fig.cap="Labor share in France", fig.show="hide", warning=F}
pwt %>% 
  subset(Year %in% c(1950:2017)) %>% 
  select(Country, Year, contains("lab_sh")) %>% 
  subset(Country == "France") %>%
  mutate(lab_sh1 = ifelse(i_lab_sh1 == 1, lab_sh1, NA),
         lab_sh2 = ifelse(i_lab_sh2 == 1, lab_sh2, NA),
         lab_sh3 = ifelse(i_lab_sh3 == 1, lab_sh3, NA),
         lab_sh4 = ifelse(i_lab_sh4 == 1, lab_sh4, NA)) %>% # Remove interpolated labor share by the PWT
  select(Year, starts_with("lab_sh")) %>% 
  setDT %>% melt(id.vars = "Year") %>%  
  mutate(variable = factor(variable,
    labels = c("Mixed income", "Part mixed income",
               "Average wage", "Agriculture"))) %>% 
  
  ggplot(aes(x = Year, y = value)) +
  geom_line(aes(color = variable)) +
  scale_color_brewer(palette = "Set1") +
  labs(x = element_blank(), y = element_blank(), title = "Labor share", color = "Adjustment method") +
  scale_x_continuous(breaks = seq(1950,2020, 10)) +
  theme_bw() +
  theme(legend.position = "bottom") +
  ggsave(file.path(loc_graphic, "emp-ls-france-color.png"), width = 7, height = 7/1.5)
```

```{r emp-ls-show, fig.cap="Labor share in OECD countries"}
include_graphics(file.path(loc_graphic, "emp-ls-france-color.png"))
```
### Dependency ratio

Figure \@ref(fig:emp-dep) shows the old-age dependency ratio for the same sample until 2100. The old-age dependency ratio in this figure is the ratio between the population above 65 and the population between 15 and 64. The ratio slightly increases until 2000, when the boomers are young and explodes thereafter, once they retire.

```{r emp-dep, fig.cap="Old-age dependency ratio in OECD countries"}
df %>% 
  subset(Year %in% c(1970:2080)) %>% 
  select(Country, Year, dep_65) %>% 
  subset(Country %in% c("Australia", "France", "Japan", "United States")) %>%
  
  ggplot(aes(x = Year, y = dep_65, color = Country)) +
  geom_line() +
  scale_color_brewer(palette = "Set1") +
  scale_x_continuous(breaks = seq(1970, 2080, 20)) +
  labs(x = element_blank(), y = element_blank(), title = "Old-age-dependency ratio",
       color = element_blank()) +
  theme_bw() + theme(legend.position = "bottom") +
  ggsave(file.path(loc_graphic, "emp-dep-color.png"), width = 7, height = 7/1.5)
```

### Correlations

Figure \@ref(fig:emp-lsdep) plots the labor share and the old age dependency ratio for a larger sample of countries from 1970 to 2010. The labor share adjustment method for the self-employed is mixed income.


```{r emp-lsdep, fig.cap="Labor share and old-age dependency ratio in OECD countries"}
df %>% 
  subset(Year %in% c(1970:2010)) %>% 
  select(Country, Year, lab_sh1, i_lab_sh1, dep) %>% 
  subset(Country %in% c("Australia", "Belgium", "Canada", "Denmark", "France", "Germany", "Japan", "United States", "Netherlands", "United Kingdom")) %>%
  mutate(lab_sh1 = ifelse(i_lab_sh1 == 1, lab_sh1, NA)) %>% select(-i_lab_sh1) %>% # Remove interpolated
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  
  ggplot(aes(x = Year, y = value, color = Country)) +
  geom_line() +
  facet_wrap(variable ~ ., scales = "free",
             labeller = labeller(variable = c(lab_sh1 = "Labor share", dep = "Old-age dependency ratio"))) +
  labs(x = "Year", y = element_blank(), color = element_blank()) +
  theme_bw() + theme(legend.position = "bottom") +
  ggsave(file.path(loc_graphic, "emp-lsdep-color.png"), width = 7, height = 7/1.5)
```

Figure \@ref(fig:emp-lsdepcor) plots the labor share and the old age dependency ratio for a larger sample of countries from 1970 to 2010. The blue line corresponds to the linear regression line and the grey area is the 95% confidence interval.  The labor share adjustment method for the self-employed is mixed income.

```{r emp-lsdepcor, fig.cap="Correlation between the old-age dependency ratio and the labor share in OECD countries", echo=F}
require(ggpmisc)
df %>% 
  subset(Year %in% c(1970:2010)) %>% 
  select(Country, Year, lab_sh1, i_lab_sh1, dep) %>% 
  subset(Country %in% c("Australia", "Belgium", "Canada", "Denmark", "France", "Germany", 
                        "Japan", "United States", "Netherlands", "United Kingdom")) %>%
  subset(i_lab_sh1 == 1) %>% # Remove interpolated
  
  ggplot(aes(x = dep, y = lab_sh1)) +
  geom_point(aes(color = Country)) +
  geom_smooth(method = "lm", formula = y ~ x) +
  stat_poly_eq(formula = y ~ x, label.x = .9, label.y = .9,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
               parse = TRUE) +         
  labs(x = "Old-age-dependency ratio", y = "Labor share", color = element_blank()) +
  theme_bw() + theme(legend.position = "right") +
  ggsave(file.path(loc_graphic, "emp-lsdepcor-color.png"), width = 7, height = 7/1.5)
```

# Quantitative analysis

This section provides the details of the quantitative analysis in the paper. I consider model simulations from 1970 to 2080, every 10 years, for France and the United States; see the paper for more details.

```{r quant-init}
# Simulation periods
sim = seq(1970, 2080, 10)
# Estimation sample
est_sample = c(1970:2010)
# Graphic parameters
breaks_10_years = seq(1970, 2080, 10)
labs_20_years = as.vector(rbind(seq(1970, 2080, 20), rep("", length(breaks_10_years)/2)))
scale_graph = 1920/1080
```

## Data

I select variables from the different data sources for France and the United States since 1970 and merge them all into one dataset.

```{r data-merge}
# Penn World Table 9.1
pwt0 = pwt %>%
  select("Country", "Year", "emp", "avh", "rgdpna", "rnna", "lab_sh1", "lab_sh2") %>% 
  subset(Country %in% CountrySet & Year >= 1970)
# OECD data
oecd0 = oecd %>% 
  select("Country", "Year", tax_rate = "tax_rev_PC_GDP",
         union_density = "union_density.lin_inter",
         union_coverage = "union_coverage.lin_inter") %>% 
  subset(Country %in% CountrySet & Year >= 1970)
# Demographic data
demo0 = demo %>% 
  select("Country", "Year", "young", "young_1564", "old", "dep", "n", "p") %>% 
  subset(Country %in% CountrySet)
## Merge
df0 = merge(pwt0, oecd0, all = TRUE) %>% merge(demo0, all = TRUE) %>% 
  subset(Year >= 1970)
```

Employment, $emp_t$, from the PWT are expressed in thousand, thus, I multiply $emp_t$ by 1000. I divide capital stock $K_t$ and output $Y_t$ by the average hours worked $avh_t$ to disantangle the effect of changes in hours worked. The labor share $\theta_t$ corresponds to mixed income adjustment method, i.e. self employed income is considered as labor compensation (in line with the theoretical framework). The tax rate $\tau_t$ from OECD database is in percent, thus, I divide it by 100. The unemployment rate $u_t$ is computed using the employment data from the PWT and the number of young individuals from the WPP. Lastly, the expected survival rate $p_{t+1}$ is the survival rate of the next period of the sequence, so 40 years after. $N^y$ and $N^o$ are, respectively, the number of young and old households. $n$ is the gross rate of population growth.
Then, I normalize labor and capital to their value in 1970. The capital-per-worker is therefore normalized. Population is also normalized to match the unemployment rate computed above.

```{r data-variables}
# Variable modifications
df1 = df0 %>%
  group_by(Country) %>% 
  mutate(L = emp * 1000, # Labor
         Y = rgdpna / avh * 1000, # Output with AVH control
         K = rnna / avh * 1000, # Capital with AVH control
         theta = lab_sh1, # Labor share
         tau = tax_rate / 100, # Tax rate
         u = 1 - L/young_1564, # Unemployment rate
         p1 = lead(p, 40), # Expected survival rate
         ) %>% 
  select(Country, Year, Ny = young, No = old, n, p, p1, dep, K, L, Y, theta, tau, u) %>% 
  # Normalized labor and capital
  mutate_at(vars("L", "K"), ~ {./first(.)}) %>% 
  # Normalized capital-labor ratio, young and old population
  mutate(k = K/L, Ny = L/(1-u), No = Ny*dep) %>% 
  ungroup() %>% 
  # Remove unused countries from Country levels
  mutate(Country = Country %>% as.character %>% factor)
# Preview
head(df1)
```

I prepare the dataset for simulation. I complete NA values for $p_{t+1}$ in 2070 and 2080 because demographic data ends in 2100. Thus, the expected survival rate in 2070 corresponds to the survival rate in 2110 which is not available. To complete those NA values, I assume the survival rate grows at the same rate as during the last decade.

```{r data-baseline}
# Initial Sequence
init_seq = seq(1970, 2000, 10)
# Baseline data
data_base = df1 %>% 
  # Keep years simulation
  group_by(Country) %>% subset(Year %in% sim) %>% 
  # Select predetermined variables of the 1st sequence
  select(Country, Year, Ny, No, n, p, p1, K) %>% 
  # Define Sequence and Period
  mutate(Sequence = ((sim - 1970)/10) %% 4 + 1, Period = (sim - init_seq) / 40 + 1) %>%
  # Remove values for Ny, No and K after the 1st periods
  mutate_at(vars("Ny", "No", "K"), ~ ifelse(Year >= 2010, NA, .)) %>% 
  # Complete NA values for p1 in 2070 and 2080
  mutate(
    p1 = ifelse(Year >= 2070,
                p1[Year == 2060] + (Year - 2060)/10 * mean(p1/lag(p1)-1, na.rm = T),
                p1),
    ## Create empty variables
    eta = NA, AK = NA, AL = NA, k1 = NA, k2 = NA, k = NA, X = NA, L = NA, w = NA,
    r = NA, Y = NA, u = NA, theta = NA, tau = NA, b = NA, h = NA, S = NA) 
# Re-order variables
data_base = data_base %>% 
  select(Country, Year, Sequence, Period, Ny, No, n, p, p1, eta, AK, AL,
         k1, k2, k, X, L, w, r, Y, u, theta, tau, b, h, S, K)
# Preview
head(data_base, 10)
```
The demo_changer function computes the young and old population sizes such that $N^y_t = n_t \times N^y_{t-1}$ and $N^o_t = p_t \times N^y_{t-1}$. The young population at previous period corresponds to the young population 40 years before.

```{r data-demo}
# Demography
data = data_base %>% 
  # No biased technical change
  mutate(AK = 1, AL = 1) %>% 
  # Population dynamics
  demo_changer(init_spe = TRUE)
# Preview
head(data, 10)
```
Figure \@ref(fig:graph-demo) presents time trends of the demographic variables. This figure corresponds to Figure 1 in the paper.

```{r graph-demo, fig.cap="Demographic variables: Time trends"}
graph_demo = data %>% mutate(dep = p/n) %>% # Compute old-age dependency ratio
  select(Country, Year, n, p, dep) %>% 
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  
  ggplot(aes(x = Year, y = value, color = Country)) +
  geom_line() +
  facet_wrap(. ~ variable, scales = "free_y",
    labeller = labeller(variable = c(n = "Population growth (n)", p = "Survival rate (p)",
                                     dep = "Old-age dependency ratio (p/n) "))) +
  scale_x_continuous(breaks = breaks_10_years,
                     labels = c(1970, "", "", 2000, "", "", 2030, "", "", 2060, "", "")) +
  theme_bw() + theme(legend.position = "bottom") +
  labs(x = element_blank(), y = element_blank(), color = element_blank())

# Paper version
graph_demo + scale_color_grey(start = 0, end = .5) +
  ggsave(file.path(loc_graphic, "quant-demo.png"), width = 7, height = 7/2.5)

# Color version
graph_demo + scale_color_brewer(palette = "Set1")
  ggsave(file.path(loc_graphic, "quant-demo-color.png"), width = 7, height = 7/2.5)
```

## Calibration

There are 7 parameters in the model. The discount rate $\alpha$ is set at 0.669, i.e. 0.99 on annual basis. I set the relative bargaining power of the union $\gamma$ to 0.5, thus, neither the union nor the firm have an advantage in the bargaining apart from their respective outside options.

```{r calib-alpha-gamma}
# Set Alpha and Gamma (same for all countries)
param_base = data.frame(
  "Country" = rep(c("France", "United States"), each = length(sim)),
  "Year" = sim, "alpha" = (0.99)^40, "gamma" = 0.5)
```

I estimate the elasticity of substitution between capital and labor $\sigma$. For more details, see appendix C in the paper. The parameter $\phi$ corresponds to the capital share in 1970, so $1-\theta_{1970}$.

```{r calib-sigma}
# Dataframe for estimation of sigma
df1.sigma0 = df1 %>% 
  group_by(Country) %>% 
  mutate(k_log = log(k), # Log capital-per-worker with AVH control
         THETA_log = log(theta/(1-theta)), # Labor-to-capital income ratio
         t_diff = Year - first(Year) # Time trend for biased technical change
         ) %>% 
  # Keep variables
  select(Country, Year, k_log, THETA_log, t_diff) %>%
  # Estimation on data from 1970 to 2010
  subset(Year %in% c(1970:2010)) %>% 
  ungroup()

# Regressions to estimate sigma
list.sigma = list(
  ## France
  France = list(
    # One for all
    all = lm(THETA_log ~ k_log + t_diff, data = df1.sigma0, 
             subset = Country == "France") %>% 
      coef %>% {1/(1+.[2])} %>% unname,
    # Before 1985 (see appendix D in the paper)
    before85 = 1,
    # After 1985 (see appendix D in the paper)
    after85 = lm(THETA_log ~ k_log, data = df1.sigma0,
               subset = Country == "France" & Year > 1985) %>% 
      coef %>% {1/(1+.[2])} %>% unname
  ),
  ## United-States
  `United States` = list(
    all = lm(THETA_log ~ k_log, data = df1.sigma0, 
             subset = Country == "United States") %>% 
    coef %>% {1/(1+.[2])} %>% unname
    )
)

# Add production function parameters
param_base = param_base %>%
  # Phi = 1 - theta in 1970
  merge(df1 %>% subset(Year == 1970) %>% mutate(phi = 1-theta) %>% select(Country, phi)) %>% 
  # Sigma are those obtained from regressions above
  merge(data.frame(Country = c("France", "United States"),
                   sigma = c(list.sigma$France$all, list.sigma$`United States`$all))) %>% 
  # No Biased technical change
  mutate(a = NA)
```

The parameters $\omega$ and $\beta$ are calibrated to match the data. To calibrate them, I consider the elasticity of substitution $\sigma$ as estimated in appendix C. Thus, for France, there is only one regime yet. 
To calibrate $\omega$, I compute the net replacement rate in unemployment $X_t$ at the labor market equilibrium in 1970 with $\phi$, $\gamma$, $\sigma$ and $k_t$ (equal to 1 in 1970). Using $X_t$, I compute the the political weight of the young in 1970 at the public policy equilibrium. Thus, $\omega$ is set such that the capital-per-worker is at the equilibrium in 1970.
Then, $\beta$ is set to match the tax rate $\tau_t$ in 1970.

```{r calib-omega-beta}
# Compute omega and beta
param_base = param_base %>%
  merge(., df1) %>% 
  mutate(X = exp(-(sigma + (1-phi)/phi*(1-gamma*(1-sigma))/gamma*k^((1-sigma)/sigma))^(-1)),
         # eta = (1-phi)/phi*k^((1-sigma)/sigma) * ((Ny/K*k-1)*X + 1),
         eta = Ny/K*k*((1+phi/(1-phi)*k^((sigma-1)/sigma))/X-1)^(-1), # model2
         omega = p/n/(1+alpha*p1)*eta,
         # beta = 1/(1 - tau)/(1-theta) - 1 - eta,
         beta = ((1+eta)*tau-u*eta)/(1-tau),# model2
         ) %>% 
  group_by(Country) %>% 
  mutate(omega = first(omega), beta = first(beta)) %>%
  # mutate_at(vars(omega, beta), ~ mean(., na.rm = T)) %>% 
  select(Country, Year, alpha, gamma, phi, sigma, a, omega, beta) %>% 
  ungroup()
# Preview
param_base[c(1,13),]
```

Considering appendix D, there are two regimes in the elasticity of substitution between capital and labor in France. Thus, the elasticity is about 1 before 1985 and about 1.32 thereafter.

```{r calib-sigma-france}
# # Change sigma for France
# param_base = param_base %>% 
#   mutate(sigma = ifelse(Country == "France",
#                         ifelse(Year <= 1985, list.sigma$France$before85,
#                                list.sigma$France$after85), sigma))
```

To set the scale parameter of the production function $A$, I match the average labor share between 2008 and 2012.

```{r calib-A}
## Grid search for A (scale parameter)
# Set data
data = data_base %>% 
  # No biased technical change
  mutate(AK = 1, AL = 1) %>% 
  # Add parameters
  merge(param_base) %>% 
  # Demography
  demo_changer(AFinder = TRUE)
# A Finder script
source(file.path(loc_script, "sim_AFinder.R"))
# Assign A scale parameter to param_base
param_base$A = data$A
# Assign values
param = param_base
# Preview
param_base[c(1,13),]
```

Table \@ref(tab:tab-param) summarizes the parameters for both countries. This table corresponds to Table 1 in the paper.

```{r tab-param}
# Print parameters in the table
coef_summary = param_base %>% 
  subset(Year == 2010) %>% mutate_if(is.numeric, ~ round(., 3)) %>% 
  select(Country, phi, gamma, alpha, sigma, omega, beta, A) %>% 
  setDT %>% melt(id.vars = "Country") %>% 
  dcast(variable ~ Country, value.var = "value") %>% 
  mutate(
    variable = c("$\\phi$", "$\\gamma$", "$\\alpha$", "$\\sigma$", 
                 "$\\omega$", "$\\beta$", "$A$"),
    var_desc = c("Capital share in 1970", "Relative bargaining power of the union",
                 "Discount rate", "Capital-labor elasticity of substitution",
                 "Relative ideological spread-out", 
                 "Preference for government health expenditure", 
                 "Scale parameter of the production function")
  ) %>% 
  select(variable, var_desc, everything())

# Table infos
coef_table_col.names = c("", "Parameter", "France", "United States")

# Save table in TeX format
coef_summary %>% 
  kable(format = "latex", col.names = coef_table_col.names, 
        booktabs = TRUE, linesep = "", escape = FALSE) %>% 
  row_spec(0, bold=TRUE) %>% 
  writeLines(., con = "_tabular/quant-param.tex")

# Print table in html format
coef_summary %>% 
  kable(col.names = coef_table_col.names, align = "llrr") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE) %>% 
  row_spec(0, bold=TRUE) 
```

I define break years for future counterfactual simulations. The breakers datable contains all the demographic variables according per decade.

```{r breakers}
breakers = demo0 %>% 
  ## Compute demographic data for 1960
  subset(Year == 1960) %>% 
  mutate(Sequence = NA, Period = NA, Ny = NA, No = NA, p1 = NA) %>% 
  select(Country, Year, Sequence, Period, Ny, No, n, p, p1) %>% 
  rbind(., data_base %>% 
          select(Country, Year, Sequence, Period, Ny, No, n, p, p1) %>% 
          subset(Year == 2000) %>% 
          ungroup()) %>% 
  group_by(Country) %>% 
  mutate(p1 = ifelse(Year == 1960, dplyr::lead(p), p1),
         Ny = ifelse(Year == 1960, dplyr::lead(Ny)/dplyr::lead(n), Ny),
         No = ifelse(Year == 1960, p/n*Ny, No),
         Sequence = ifelse(Year == 1960, 4, Sequence),
         Period = ifelse(Year == 1960, 0, Period)) %>% 
  subset(Year == 1960) %>% 
  ungroup() %>% 
  ## Demographic data thereafter
  rbind(., data_base %>% 
          select(Country, Year, Sequence, Period, Ny, No, n, p, p1) %>% 
          ungroup()) %>% 
  arrange(Country) %>% 
  merge(., param_base %>% select(Country, alpha, omega) %>% unique()) %>% 
  group_by(Country, Sequence) %>% 
  mutate(eta = n/p*(1+alpha*p1)*omega,
         Ny = ifelse(Period == 2, lag(Ny,1)*n, Ny),
         No = ifelse(Period == 2, lag(Ny,1)*p, No),
         Ny = ifelse(Period == 3, lag(Ny,1)*n, Ny),
         No = ifelse(Period == 3, lag(Ny,1)*p, No),) %>% 
  select(-alpha, -omega) %>% 
  ungroup()
# Preview
head(breakers, 10)
```

I regroup all simulations in a list.

```{r sim-list}
# Empty list of simulations
list.sim = list()
```

## Model predictions 

The following simulation and graphics refer to the benchmark simulation.

### Simulation

I simulate the model for France and the United States.

```{r sim-benchmark}
# Specification
spe = "benchmark"

# Initialize result dataset
final = data.frame(matrix(ncol = ncol(data)+ ncol(param) -2 + 1, nrow = 0)) %>%
  setNames(c("Specification", names(data), names(param)[-c(1,2)]))

# Prepare data for simulation
data = data_base %>% 
  # Merge with parameters
  merge(param) %>% 
  # No BTC
  mutate(AK = 1, AL = 1) %>% 
  # Demography
  demo_changer() %>% 
  # Define specification model
  mutate(Specification = spe) %>%
  # Reorder variables
  select(Specification, everything())

# Prepare result data frame to loop on
result = final

# Simulate the benchmark model for each country in CountrySet
for(country in CountrySet){
    result = data %>%
      subset(Country == country) %>% 
      model2(time = 3) %>% 
      rbind(result, .)
}

# Regroup result
list.sim$benchmark = result
```

### Graphics

Figure \@ref(fig:graph-bench-ls) shows the labor share predictions of the model and the labor share in the data from 1970 to 2080 for France and the United States. Labor share data are from PWT with self-employed income as labor compensation. This figure corresponds to Figure 2 in the paper.

```{r graph-bench-ls, fig.cap="Model predictions of the labor share"}
graph_bench_LS = list.sim$benchmark %>% 
  select(Country, Year, theta) %>% setDT %>% 
  melt(id.vars = c("Country", "Year")) %>% 
  rbind(df1 %>% select(Country, Year, theta) %>% setDT %>% 
          melt(id.vars = c("Country", "Year")) %>% mutate(variable = "data")
        ) %>% 
  filter(complete.cases(.)) %>% 
  mutate(variable = factor(variable, levels = c("data", "theta"))) %>% 
  
  ggplot(aes(x = Year, y = value, color = Country, linetype = variable)) +
  geom_line() +
  scale_x_continuous(breaks = breaks_10_years, labels = breaks_10_years) +
  scale_linetype_discrete(label = c("Data", "Model prediction")) +
  labs(x = element_blank(), y = element_blank(), title = "Labor share",
       linetype = element_blank(), color = element_blank()) +
  theme_bw() +
  theme(legend.position = "bottom")
  
# Paper version
graph_bench_LS +
  scale_color_grey(start = 0, end = .5) +
  ggsave(file.path(loc_graphic, "quant-bench-ls.png"), width = 7, height = 7/1.5)

# Color version
graph_bench_LS +
  scale_color_brewer(palette = "Set1") +
  annotate("text", x = 2000, y = .71, label = "France", color = brewer.pal(8, "Set1")[1]) +
  annotate("text", x = 2000, y = .61, label = "United-States", color = brewer.pal(8, "Set1")[2]) +
  guides(color = "none") +
  ggsave(file.path(loc_graphic, "quant-bench-ls-color.png"),  width = 7, height = 7/1.5)
```

Figure \@ref(fig:graph-bench-dev7010) shows the deviation of the variables from their 1970’s value (in percentage) for France and the United States over the 1970-2010 period. Solid lines represent the dynamics obtained from the model simulation, whereas the dotted line represents the 0-degree line. This figure corresponds to Figure 3 in the paper.

```{r graph-bench-dev7010, fig.cap="Variables dynamics over the 1970-2010 period"}
graph_dev7010 = list.sim$benchmark %>% 
  group_by(Country) %>% 
  mutate(outside = b/(1-tau)) %>% 
  select(Country, Year, eta, outside, w, L, u, K, Y, theta) %>% 
  mutate_at(vars(eta, outside, w, L, u, K, Y, theta), ~ (./.[Year == 1970]-1)*100) %>% 
  subset(Year %in% c(1970:2010)) %>% 
  # Variables and names
  select(Country, Year,
         "Political~weight~of~the~young~(eta)" = eta,
         # "Outside~option" = outside,
         "Wage~rate~(w)" = w, 
         "Labor~(L)" = L, 
         "Unemployment~rate~(u)" = u,
         # "Capital~(K)" = K,
         "Output~(Y)" = Y
         # "Labor~share~(theta)" = theta
         ) %>% 
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  
  ggplot(aes(x = Year, y = value, color = Country)) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  geom_line() +
  facet_wrap(. ~ variable, scales = "free", nrow = 2, labeller = label_parsed) +
  scale_x_continuous(breaks = seq(1970, 2010, 10), labels = c("1970","", "1990", "", "2010")) +
  labs(x = element_blank(), y = "Percentage deviation (1970 = 0)", color = element_blank()) +
  theme_bw() +
  theme(legend.position = c(0.95, 0.4), legend.justification = c(1,1),
        legend.text = element_text(size=12),
        panel.spacing.x = unit(1, "lines"))

# Paper version
graph_dev7010 +
  scale_color_grey(start = 0, end = .5) +
  ggsave(file.path(loc_graphic, "quant-bench-dev7010.png"), width = 7, height = 7/1.5)


# Color version
graph_dev7010 +
  scale_color_brewer(palette = "Set1") +
  ggsave(file.path(loc_graphic, "quant-bench-dev7010-color.png"), width = 7, height = 7/1.5)
```

Figure \@ref(fig:graph-bench-dev1080) shows the deviation of the variables from their 2010’s value (in percentage) for France and the United States over the 2010-2080 period. Solid lines represent the dynamics obtained from the model simulation, whereas the dotted line represents the 0-degree line. This figure corresponds to Figure 4 in the paper.

```{r graph-bench-dev1080, fig.cap="Variables dynamics over the 2010-2080 period"}
graph_dev1080 = list.sim$benchmark %>% 
  group_by(Country) %>% 
  mutate(outside = b/(1-tau)) %>% 
  select(Country, Year, eta, outside, w, L, u, K, Y, theta) %>% 
  mutate_at(vars(eta, outside, w, L, u, K, Y, theta), ~ (./.[Year == 2010]-1)*100) %>% 
  subset(Year %in% c(2010:2080)) %>% 
  # Variables and names
  select(Country, Year,
         "Political~weight~of~the~young~(eta)" = eta,
         # "Outside~option" = outside,
         "Wage~rate~(w)" = w, 
         "Labor~(L)" = L, 
         "Unemployment~rate~(u)" = u,
         # "Capital~(K)" = K,
         "Output~(Y)" = Y,
         # "Labor~share~(theta)" = theta
         ) %>% 
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  
  ggplot(aes(x = Year, y = value, color = Country)) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  geom_line() +
  facet_wrap(. ~ variable, scales = "free", nrow = 2, labeller = label_parsed) +
  scale_x_continuous(breaks = seq(2010, 2080, 10), labels = c("2010","", "2030", "", "2050", "", "2070", "")) +
  labs(x = element_blank(), y = "Percentage deviation (2010 = 0)", color = element_blank()) +
  theme_bw() +
  theme(legend.position = c(0.95, 0.4), legend.justification = c(1,1), 
        legend.text = element_text(size=12),
        panel.spacing.x = unit(1, "lines"))

# Paper version
graph_dev1080 + 
  scale_color_grey(start = 0, end = .5) +
  ggsave(file.path(loc_graphic, "quant-bench-dev1080.png"), width = 7, height = 7/1.5)

# Color version
graph_dev1080 +
  scale_color_brewer(palette = "Set1") +
  ggsave(file.path(loc_graphic, "quant-bench-dev1080-color.png"), width = 7, height = 7/1.5)

```

## Counterfactual and decomposition

The following simulations and graphics refer to the counterfactual and decomposition analysis.

### Simulation

Table \@ref(tab:tab-demo70) summarizes the demographic variables in 1970 for France and the United States. This table corresponds to Table 2 in the paper.

```{r tab-demo70}
# Print demographic variables in 1970 in the table
tab_demo70 = list.sim$benchmark %>% 
  subset(Year == 1970) %>% mutate(dep = p/n) %>% 
  select(Country, n, p, p1, dep, eta) %>% setDT %>% 
  melt(id.vars = "Country", variable.name = "var") %>% 
  dcast(var ~ Country, value.var = "value") %>% 
  mutate(
    "var" = c("$n_{1970}$", "$p_{1970}$", "$p_{2010}$", "$\\frac{p_{1970}}{n_{1970}}$",
              "$\\eta_{1970}$"),
    "Variable" = c("Population growth rate", "Survival rate", "Expected survival rate", "Old-age dependency ratio", "Young political weight of the young")) %>% 
  mutate_if(is.numeric, ~ round(., 3)) %>% 
  select(var, Variable, everything())

# Table infos
tab_demo70.col_names = c("", "Variable", "France", "United States")

# Save table in TeX format
tab_demo70 %>% 
  kable(format = "latex", col.names = tab_demo70.col_names, booktabs = TRUE, linesep = "", escape = FALSE) %>% 
  row_spec(0, bold = TRUE) %>% 
  writeLines(., con = "_tabular/quant-demo70.tex")

# Print table in html format
tab_demo70 %>% 
  kable(col.names = tab_demo70.col_names, align = "llrr") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>% 
  row_spec(0, bold=TRUE)
```

I run the counterfactual simulations. The break year corresponds to the year at which the demographic variables remain constant, here 1970. The two first loops simulate the model to decompose the effects from both determinants, i.e. population growth (PG) and survival rate (SR). The two next loops simulate the model to decompose the effects from both channels, i.e. factor accumulation (DE, direct effect) and policy mechanism (IE, indirect effect). The letter before the effect is either T (true) or F (false). The letter T means that the determinant/channel is active, while the letter F means that it is neutralized.

```{r sim-counter}
# Re initialize result data frame
result = result[0,]
# Define break_year
break_year = 1970

## Decomposition : Survival rate versus Population growth
  for(sr in c("TSR", "FSR")){
    for(pg in c("TPG", "FPG")){
      
      # Simulation name
      spe = paste0("counter_", break_year, "_", pg, ".", sr, ".", "TDE", ".", "TIE")
      
      # Prepare data
      data = data_base %>% 
      # No biased technical change
      mutate(AK = 1, AL = 1) %>% 
      # Add parameters
      merge(param) %>% 
      # Demography
      demo_changer(break_year = break_year, p1_equals_p_fix = TRUE, PG = pg, SR = sr) %>% 
      # Define specification model
      mutate(Specification = spe) %>%
      # Reorder variables
      select(Specification, everything())
      
      # Simulate the model for each country
      for(country in CountrySet){
          result = data %>%
            subset(Country == country) %>% 
            model2(time = 3) %>% 
            rbind(result, .)
      }
    }
  }

## Decomposition : Factor accumulation versus policy mechanism
  for(de in c("TDE", "FDE")){
    for(ie in c("TIE", "FIE")){
      
      # Simulation name
      spe = paste0("counter_", break_year, "_", "TPG", ".", "TSR", ".", de, ".", ie)
      
      # Prepare data
      data = data_base %>% 
      # No biased technical change
      mutate(AK = 1, AL = 1) %>% 
      # Add parameters
      merge(param) %>% 
      # Demography
      demo_changer(break_year = break_year, p1_equals_p_fix = TRUE, DE = de, IE = ie) %>% 
      # Define specification model
      mutate(Specification = spe) %>%
      # Reorder variables
      select(Specification, everything())
      
      # Simulate the model for each country
      for(country in CountrySet){
          result = data %>%
            subset(Country == country) %>% 
            model2(time = 3) %>% 
            rbind(result, .)
      }
    }  }


# Remove duplicates because the baseline simulation in both decompositions are similar
final = distinct(result)

# Model specification details
final = final %>% 
  mutate(PG = ifelse(grepl("TPG", Specification), "TPG", "FPG"),
         SR = ifelse(grepl("TSR", Specification), "TSR", "FSR"),
         DE = ifelse(grepl("TDE", Specification), "TDE", "FDE"),
         IE = ifelse(grepl("TIE", Specification), "TIE", "FIE"),
         break_year = as.numeric(gsub("[^0-9]", "\\1", Specification))) %>% 
  select(Specification, break_year, PG, SR, DE, IE, everything())

# Preview
head(final, 10)
```

I select the labor share from all the counterfactual simulations and merge them with the labor share from the data.

```{r sim-decomp}
# Dataframe to compare the labor shares from counterfactual simulations
decomp = final %>% 
  select(Country, Specification, Year, theta) %>% 
  rbind(., 
        df1 %>% 
          mutate(Specification = paste0("data_", break_year)) %>%
          select(Specification, Country, Year, theta))  %>% 
  mutate(from = ifelse(!grepl("data", Specification), "sim", "data")) %>%
  filter(complete.cases(.)) %>% 
  mutate(PG = ifelse(from == "data", NA, ifelse(grepl("TPG", Specification), "TPG", "FPG")),
         SR = ifelse(from == "data", NA, ifelse(grepl("TSR", Specification), "TSR", "FSR")),
         DE = ifelse(from == "data", NA, ifelse(grepl("TDE", Specification), "TDE", "FDE")),
         IE = ifelse(from == "data", NA, ifelse(grepl("TIE", Specification), "TIE", "FIE")),
         break_year = as.numeric(gsub("[^0-9]", "\\1", Specification))) %>% 
  select(Specification, break_year, PG, SR, DE, IE, everything())

# Preview
head(decomp, 10)

```

I compute the size of each effect, the sum that corresponds to the difference between the labor shares from the benchmark and the baseline simulations; along with the share of each effect. Those computations are used to generate the following figures about decomposition.

```{r sim-decomp2}
# Compute the effects (size and share)
decomp2 = decomp %>% subset(from == "sim") %>% 
  mutate(Spe_PGSR = interaction(PG, SR), Spe_DEIE = interaction(DE, IE)) %>% 
  select(Country, Year, break_year, Spe_PGSR, Spe_DEIE, theta) %>% setDT %>% 
  dcast(Country + Year + break_year ~ Spe_PGSR + Spe_DEIE, value.var = "theta") %>% 
  setNames(c("Country", "Year", "break_year",
             "FPG.FSR", "TPG.FSR", "FPG.TSR", "FDE.FIE", "TDE.FIE", "FDE.TIE",
             "benchmark")) %>% 
  mutate(
    ## Determinants
    # Size of each effect
    FPG.TSR = (benchmark - FPG.TSR)*100, # Pop growth effect
    TPG.FSR = (benchmark - TPG.FSR)*100, # Survival rate effect
    FPG.FSR = (benchmark - FPG.FSR)*100, # Interaction effect (step 1)
    FPG.FSR = FPG.FSR - FPG.TSR - TPG.FSR, # Interaction effect (step 2)
    # Net effect
    position_PGSR = (FPG.TSR + TPG.FSR + FPG.FSR), # Difference between benchmark and baseline
    # Relative size of each effect
    FPG.TSR.share = abs(FPG.TSR)/(abs(FPG.TSR) + abs(TPG.FSR) + abs(FPG.FSR)), # Pop growth share
    TPG.FSR.share = abs(TPG.FSR)/(abs(FPG.TSR) + abs(TPG.FSR) + abs(FPG.FSR)), # Surv rate share
    FPG.FSR.share = abs(FPG.FSR)/(abs(FPG.TSR) + abs(TPG.FSR) + abs(FPG.FSR)), # Inter share
    ## Channels
    FDE.TIE = (benchmark - FDE.TIE)*100, # Factor-acc effect
    TDE.FIE = (benchmark - TDE.FIE)*100, # Policy mechanism effect
    FDE.FIE = (benchmark - FDE.FIE)*100, # Interaction effect (step 1)
    FDE.FIE = FDE.FIE - FDE.TIE - TDE.FIE, # Interaction effect (step 2)
    # Net effect
    position_DEIE = (FDE.TIE + TDE.FIE + FDE.FIE), # Difference between benchmark and baseline
    # Relative size of each effect
    FDE.TIE.share = abs(FDE.TIE)/(abs(FDE.TIE) + abs(TDE.FIE) + abs(FDE.FIE)), # Factor-acc share
    TDE.FIE.share = abs(TDE.FIE)/(abs(FDE.TIE) + abs(TDE.FIE) + abs(FDE.FIE)), # Policy mechanism share
    FDE.FIE.share = abs(FDE.FIE)/(abs(FDE.TIE) + abs(TDE.FIE) + abs(FDE.FIE)), # Inter share
    ) %>% 
  # Melt (from wide to long)
  setDT %>% melt(id.vars = c("Country", "Year", "break_year", "position_PGSR", "position_DEIE"))

head(decomp2, 10)
```

### Population growth and survival rate effects

Figure \@ref(fig:graph-counter-determinant) shows the labor share from counterfactual simulations, from 1970 to 2080 for France and the United States, to determine the role of each determinant. Labor share data are from PWT with self-employed income as labor compensation. This figure corresponds to Figure 14 in the paper (appendix).

```{r graph-counter-determinant}
# Counterfactual graphic parameters
pgsr_labels = c("Data", "Benchmark", "Constant population growth", "Constant survival rate",        "Baseline")

## Counterfactual PGSR
graph_pgsr_counter = decomp %>% 
  subset(DE %in% c("TDE", NA) & IE %in% c("TIE", NA)) %>%
  mutate(PGSR = interaction(PG, SR) %>% as.character %>% ifelse(is.na(.), "data", .)) %>% 
  mutate(PGSR = factor(PGSR, levels = c("data", "TPG.TSR", "FPG.TSR", "TPG.FSR", "FPG.FSR"))) %>% 
  
  ggplot(aes(x = Year, y = theta, color = PGSR, linetype = PGSR)) +
  facet_wrap(Country ~ .) +
  geom_line() +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  theme(legend.position = "bottom",) +
  labs(x = element_blank(), y = "Labor share", title = element_blank(), color = element_blank(), linetype = element_blank())

# Paper version
graph_pgsr_counter +
  scale_linetype_manual(labels = pgsr_labels, 
                        values = c("solid", "solid", "dashed", "twodash", "dotted")) +
  scale_color_manual(labels = pgsr_labels, values = c("grey", rep("black", 4))) +
  ggsave(file.path(loc_graphic, "quant-counter-determinant.png"), width = 7, height = 7/1.5)

# Color version
graph_pgsr_counter +
  scale_linetype_manual(labels = pgsr_labels, values = c("solid", rep("dashed", 4))) +
  scale_color_manual(labels = pgsr_labels, 
                     values = c("black", brewer.pal(8, "Set1")[c(1:4)])) +
  ggsave(file.path(loc_graphic, "quant-counter-determinant-color.png"), width = 7, height = 7/1.5)
 
  
```

Figure \@ref(fig:graph-decomp-determinant) shows the decomposition of the determinants of demographic changes. This figure corresponds to Figure 5 in the paper (appendix).

```{r graph-decomp-determinant}
# Labels
pgsr_labels2 = c("Population-growth effect", "Survival-rate effect", "Interaction effect")

## PGSR Decomposition
graph_pgsr_decomp = decomp2 %>%
  subset(variable %in% c("FPG.TSR", "TPG.FSR", "FPG.FSR")) %>%
  mutate(variable = factor(variable, levels = c("FPG.TSR", "TPG.FSR", "FPG.FSR"))) %>%
  
  ggplot(aes(x = Year)) +
  geom_col(aes(y = value, fill = variable), alpha = .7, position = position_stack(reverse = TRUE)) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  facet_wrap(Country ~ .) +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  theme(legend.direction = "horizontal", legend.box = "horizontal", legend.position = "bottom", axis.title.x = element_blank()) +
  labs(x = element_blank(), y = "Difference with the baseline counterfactual (in pp.)", fill = element_blank(), title = element_blank())

# Paper version
graph_pgsr_decomp +
  geom_line(aes(y = position_PGSR), color = "black") +
  scale_fill_grey(labels = pgsr_labels2, start = .1, end = .8) +
  ggsave(file.path(loc_graphic, "quant-decomp-determinant.png"), width = 7, height = 7/1.5)

# Color version
graph_pgsr_decomp + 
  geom_line(aes(y = position_PGSR), color = brewer.pal(8, "Set1")[1]) +
  scale_fill_manual(labels = pgsr_labels2, values = brewer.pal(8, "Set1")[c(2:4)]) +
  ggsave(file.path(loc_graphic, "quant-decomp-determinant-color.png"), width = 7, height = 7/1.5)

```


### Direct and indirect channels

Figure \@ref(fig:graph-counter-channel) shows the labor share from counterfactual simulations, from 1970 to 2080 for France and the United States, to determine the role of each channel. Labor share data are from PWT with self-employed income as labor compensation. This figure corresponds to Figure 14 in the paper (appendix).

```{r graph-counter-channel}
# Counterfactual graphic parameters
deie_labels = c("Data", "Benchmark", "Factor accumulation", "Policy mechanism", "Baseline")

## Counterfactual PGSR
graph_deie_counter = decomp %>% 
  subset(PG %in% c("TPG", NA) & SR %in% c("TSR", NA)) %>%
  mutate(DEIE = interaction(DE, IE) %>% as.character %>% ifelse(is.na(.), "data", .)) %>% 
  mutate(DEIE = factor(DEIE, levels = c("data", "TDE.TIE", "FDE.TIE", "TDE.FIE", "FDE.FIE"))) %>% 
  
  ggplot(aes(x = Year, y = theta, color = DEIE, linetype = DEIE)) +
  facet_wrap(Country ~ .) +
  geom_line() +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  theme(legend.position = "bottom",) +
  labs(x = element_blank(), y = "Labor share", title = element_blank(), color = element_blank(), linetype = element_blank())

# Paper version
graph_deie_counter +
    scale_linetype_manual(labels = deie_labels, values = c("solid", "solid", "dashed", "twodash", "dotted")) +
    scale_color_manual(labels = deie_labels, values = c("grey", rep("black", 4))) +
  ggsave(file.path(loc_graphic, "quant-counter-channel.png"), width = 7, height = 7/1.5)

# Color version
graph_deie_counter +
    scale_linetype_manual(labels = deie_labels, values = c("solid", rep("dashed", 4))) +
    scale_color_manual(labels = deie_labels, values = c("black", brewer.pal(8, "Set1")[c(1,5,8,4)])) +
  ggsave(file.path(loc_graphic, "quant-counter-channel-color.png"), width = 7, height = 7/1.5)
```

Figure \@ref(fig:graph-decomp-determinant) shows the decomposition of the channels of demographic changes. This figure corresponds to Figure 6 in the paper (appendix).

```{r graph-decomp-channel}
# Labels
deie_labels2 = c("Factor-accumulation effect", "Policy-mechanism effect",
                 "Interaction effect")

## DEIE Decomposition
graph_deie_decomp = decomp2 %>% 
  subset(variable %in% c("FDE.TIE", "TDE.FIE", "FDE.FIE")) %>% 
  mutate(variable = factor(variable, levels = c("FDE.TIE", "TDE.FIE", "FDE.FIE"))) %>% 
  
  ggplot(aes(x = Year)) +
  geom_col(aes(y = value, fill = variable), alpha = .7) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  facet_wrap(Country ~ .) +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  theme(legend.direction = "horizontal", legend.box = "horizontal", legend.position = "bottom") +
  labs(x = element_blank(), y = "Difference with the baseline counterfactual (in pp.)", fill = element_blank(), title = element_blank())

# Paper version
graph_deie_decomp +
  geom_line(aes(y = position_DEIE), color = "black") +
    scale_fill_grey(labels = deie_labels2, start = .1, end = .8) +
  ggsave(file.path(loc_graphic, "quant-decomp-channel.png"), width = 7, height = 7/1.5)

# Color version
graph_deie_decomp + 
  geom_line(aes(y = position_DEIE), color = brewer.pal(8, "Set1")[1]) +
  scale_fill_manual(labels = deie_labels2, values = brewer.pal(8, "Set1")[c(5,8,4)]) +
  ggsave(file.path(loc_graphic, "quant-decomp-channel-color.png"),
         width = 7, height = 7/1.5)

```

### Summary

I summarize the share of each effect over two periods: 1980-2010, i.e. when the boomers are young, and 2020-2050, i.e. when they retire.

```{r compute-decomp-sum}
# Compute the share of each effect/channel for two sub_periods 1980-2010 & 2020-2050
decomp_mean.period = decomp2 %>% select(-contains("position")) %>% setDT %>% 
  dcast(Country + Year + break_year ~ variable) %>% 
  mutate(Country_break = interaction(break_year, Country, sep = " - "),
         Period = ifelse(Year == 1970, "P0", 
                         ifelse(Year %in% c(1980:2010), "P1", 
                                ifelse(Year %in% c(2020:2050), "P2", "P3")))) %>% 
  subset(Period %in% c("P1", "P2")) %>% 
  group_by(Country_break, Period) %>% 
  select(Country_break, Period, 
         TPG.FSR.share, FPG.TSR.share, FPG.FSR.share, 
         FDE.TIE.share, TDE.FIE.share, FDE.FIE.share) %>% 
  summarise_at(vars(TPG.FSR.share:FDE.FIE.share), mean, na.rm = TRUE)
```

Figure \@ref(fig:graph-decomp-sum) summarizes the decomposition of demographic changes on the labor share over the two periods for France and the United States. This figure corresponds to Figure 7 in the paper (appendix).

```{r graph-decomp-sum}
# Summary
graph_decomp_summary = decomp_mean.period %>% setDT %>% 
  melt(id.vars = c("Country_break", "Period")) %>% 
  mutate(value = value*100) %>% 
  subset(Country_break %in% c("1970 - France", "1970 - United States")) %>% 
  mutate(Country = ifelse(Country_break == "1970 - France", "France", "United States"),
         effect = factor(ifelse(variable %>% grepl(pattern = "PG", .), "first", "second")),
         Period = ifelse(Period == "P1", "1980 - 2010", "2020 - 2050")) %>% 
  mutate(variable = factor(variable, 
    levels = c("FPG.TSR.share", "TPG.FSR.share", "FDE.TIE.share", 
               "TDE.FIE.share", "FPG.FSR.share", "FDE.FIE.share"),
    labels = c("Population growth", "Survival rate", "Factor accumulation", 
               "Policy mechanism", "Interaction", "Interaction"))) %>% 
  
  ggplot(aes(x = effect, y = value, fill = variable)) +
  facet_grid(Country ~ Period) +
  scale_x_discrete(breaks = c("first", "second"), 
                   labels = c("Determinants", "Channels")) +
  theme_bw() +
  theme(legend.direction = "horizontal", legend.position = "bottom") +
  labs(x = element_blank(), y = "Share of the effect (in percentage)", fill = element_blank())

# Paper version
graph_decomp_summary +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  scale_fill_grey(start = 1, end = 0) +
  ggsave(file.path(loc_graphic, "quant-decomp-sum.png"), width = 7, height = 7/1.5)

# Color version
graph_decomp_summary +
    geom_bar(stat = "identity", position = position_dodge(), alpha = .7) +
    scale_fill_manual(values = brewer.pal(8, "Set1")[c(2,3,5,8,4)]) +
  ggsave(file.path(loc_graphic, "quant-decomp-sum-color.png"), 
         width = 7, height = 7/1.5)
```

# Discussion

This section provides the details of the discussion in the paper.

## Age-related conflict: who are the winners ?

I use the benchmark simulation to compute the expected life-time utility and the details on how the total income is allocated within the economy.

```{r winners-redis}
# Utility and GDP split
redis = list.sim$benchmark %>%
  group_by(Country, Sequence) %>% 
  # Compute Utility
  mutate(
    # Expected income
    y = (1-u)*(1-tau)*w+u*b,
    # Consumption 1st period
    c1 = log(y/(1+alpha*p1)),
    # Consumption 2nd period
    c2 = alpha*p1/(1+alpha*p1)*(1-lead(tau,1))*y*r/p,
    # Life-time utility
    utility = log(c1) + alpha*p1*(log(c2) + beta*log(lead(h,1)))
    ) %>% 
  # Compute GDP split
  mutate(
    # Step 1: labor and capital income
    wL = w*L, rK = r*K,
    # Step 2
    wL_net = (1-tau)*wL, rK_net = (1-tau)*rK, gov_rev = tau*Y,
    # Step 3
    unemp_ben = b*u*Ny, health_spen = h*No,
    # Step 4
    C1 = 1/(1+alpha*p1)*(wL_net+unemp_ben),
    Saving = alpha*p1/(1+alpha*p1)*(wL_net+unemp_ben),
    C2 = rK_net,
    # Incomes of the young and the old
    inc_y = wL_net + unemp_ben, inc_o = rK_net,
    # Labor share and dependency ratio
    theta = wL/Y, dep = p/n,
    ) %>% 
  ungroup()
```

Figure \@ref(fig:winners-utility) shows the expected life time utility and the expected survival rate for an individual born in year $t$, according to benchmark simulation. Both are highly correlated because the expected survival rate affects utility through the probability to survive and also the propensity to consume. Thus, comparing two generations on the basis of their utility to assess the winner of the inter-generational conflict does not make sense.

```{r winners-utility, fig.cap = 'Expected life time utility and expected survival rate'}
## Core
graph_utility = redis %>% 
  # Select expected life time utility and expected survival rate
  select(Country, Year, utility, p1) %>% subset(Year %in% c(1970:2040)) %>% 
  # Melt (from wide to long)
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  # Rename variables
  mutate(variable = factor(variable, labels = c("Expected~life~time~utility", "Expected~survival~rate"))) %>% 
  
  ggplot(aes(x = Year, y = value, color = Country)) +
  geom_line() +
  facet_wrap(variable ~ ., scales = "free_y", labeller = label_parsed) +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  labs(x = element_blank(), y = element_blank(), title = element_blank(), linetype = element_blank(), color = element_blank()) +
  theme(legend.position = "right")

# Color version
graph_utility + scale_color_grey(start = 0, end = .5) +
  ggsave(file.path(loc_graphic, "discuss-utility.png"), width = 7, height = 7/2)

# Paper version
graph_utility + scale_color_brewer(palette = "Set1") +
  ggsave(file.path(loc_graphic, "discuss-utility-color.png"), width = 7, height = 7/2)

```

Figure \@ref(fig:winners-ratio) shows the (before-tax) young-to-old and (after-tax) labor-to-capital income ratios in percentage deviation from their 1970's values. These variables are aggregate variables and therefore do not take into account generation sizes.

```{r winners-ratio, fig.cap = 'Income ratio dynamics'}
## Core
graph_ratio = redis %>% 
  select(Country, Year, inc_y, inc_o, wL, rK, eta) %>% 
  group_by(Country) %>% 
  # Young-to-old income ratio and labor-to-capital income ratio
  mutate(inc_ratio = inc_y/inc_o, lab_to_cap_ratio = wL/rK) %>%
  # In % deviation from 1970
  mutate_at(vars(contains("ratio")), ~ {(./.[Year == 1970] -1)*100}) %>% 
  # Select variables
  select(Country, Year, lab_to_cap_ratio, inc_ratio) %>% 
  # Melt (from wide to long)
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  # Rename ratios
  mutate(variable = factor(variable, labels = c("Before-tax", "After-tax"))) %>% 
  
  ggplot(aes(x = Year, y = value, linetype = variable, color = Country)) +
  geom_line() +
  geom_hline(yintercept = 0, linetype = "dotted") +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  labs(x = element_blank(), y = element_blank(), title = "Income ratio in percentage deviation (1970 = 0)", linetype = element_blank(), color = element_blank()) +
  theme(legend.position = "right")

# Color version
graph_ratio + scale_color_grey(start = 0, end = .5) + 
  ggsave(file.path(loc_graphic, "discuss-ratio.png"), width = 7, height = 7/2)

# Paper version
graph_ratio + scale_color_brewer(palette = "Set1") +
  ggsave(file.path(loc_graphic, "discuss-ratio-color.png"), width = 7, height = 7/2)

```

Figure \@ref(fig:winners-ratio-pc) shows the per-capita (before-tax) young-to-old and (after-tax) labor-to-capital income ratios in percentage deviation from their 1970's values. These variables take into account changes in generation sizes.

```{r winners-ratio-pc, fig.cap = 'Per-capita income ratio dynamics'}
## Core
graph_ratio_pc = redis %>% 
  select(Country, Year, inc_y, inc_o, wL, rK, eta, dep) %>% 
  group_by(Country) %>% 
  # Young-to-old income ratio and labor-to-capital income ratio (PER CAPITA)
  mutate(inc_ratio = inc_y/inc_o*dep, lab_to_cap_ratio = wL/rK*dep) %>% 
  # In % deviation from 1970
  mutate_at(vars(contains("ratio")), ~ {(./.[Year == 1970] -1)*100}) %>% 
  # Select variables
  select(Country, Year, lab_to_cap_ratio, inc_ratio) %>% 
  # Melt (from wide to long)
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  # Rename ratios
  mutate(variable = factor(variable, labels = c("Before-tax", "After-tax"))) %>% 
  
  ggplot(aes(x = Year, y = value, linetype = variable, color = Country)) +
  geom_line() +
  geom_hline(yintercept = 0, linetype = "dotted") +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  labs(x = element_blank(), y = element_blank(), title = "Per-capita young-to-old income ratio in percentage deviation (1970 = 0)", linetype = element_blank(), color = element_blank()) +
  theme(legend.position = "right")

# Color version
graph_ratio_pc + scale_color_grey(start = 0, end = .5) +
  ggsave(file.path(loc_graphic, "discuss-ratiopc.png"), width = 7, height = 7/2)

# Paper version
graph_ratio_pc + scale_color_brewer(palette = "Set1") +
  ggsave(file.path(loc_graphic, "discuss-ratiopc-color.png"), width = 7, height = 7/2)

```

Figure \@ref(fig:winners-gdpshare) shows the decomposition of total income between net labor income, unemployment benefits, health spending and capital income. The dashed line corresponds to the labor share which represents the gross labor income. When the dashed line lies in the unemployment spending area, it means that the gross labor income is smaller than the total young income (net labor income + unemployment spending). In this case, the young increase their income through redistribution. Conversely, when the dashed line lies in the health spending area, it means that the old reduce the total income of the young through redistribution in order to finance health spending.

```{r winners-gdpshare, fig.cap = 'Decomposition of total income'}
## Decomposition of GDP between net labor income, unemp. benefits, health spending and net capital income
graph_gdpshare = redis %>% 
  # Variables in share of GDP
  mutate_at(vars(wL_net, unemp_ben, health_spen, rK_net), ~ {./Y}) %>% 
  # Select variables and labor share
  select(Country, Year, rK_net, health_spen, unemp_ben, wL_net, theta) %>% 
  # Melt (from wide to long)
  setDT %>% melt(id.vars = c("Country", "Year", "theta")) %>%
  # Rename variables
  mutate(variable = factor(variable, 
    levels = c("rK_net", "health_spen", "unemp_ben", "wL_net"), 
    labels = c("Net capital income", "Health spending", "Unemployment spending", "Net labor income"))
    ) %>% 
  
  # Plot
  ggplot(aes(x = Year)) +
  geom_col(aes(y = value, fill = variable)) +
  geom_line(aes(y = theta), linetype = "dashed", color = "black") +
  facet_wrap(Country ~ .) +
  scale_x_continuous(breaks = breaks_10_years, labels = labs_20_years) +
  theme_bw() +
  theme(legend.position = "bottom", panel.spacing.x = unit(1.5, "lines")) +
  labs(x = element_blank(), y = "Share of GDP", title = element_blank(), fill = element_blank())

# Paper version
graph_gdpshare + 
  scale_fill_grey(start = .8, end = 0) +
  ggsave(file.path(loc_graphic, "discuss-gdpshare.png"), width = 7, height = 7/2)
  
# Color version
graph_gdpshare + 
    scale_fill_manual(values = brewer.pal(8, "Set3")[c(4,6,3,5)]) +
  ggsave(file.path(loc_graphic, "discuss-gdpshare-color.png"), width = 7, height = 7/2)

```

## Retirement age

I suppose a change in the age of retirement occurs between 2020 and 2030. I consider 3 scenarii, see the paper for more details.

```{r sim-retage}
# Define break_year
break_year = 2020
# Define first years after the reform
first_years = seq(break_year+10, (break_year+40), by = 10)

# Init ret_age
list.sim$retage = data.frame(matrix(ncol = ncol(result)+3, nrow = 0)) %>%
  setNames(c(names(result), c("p_fix", "p1_to_p_dist", "shock")))

for(spe in c(1:3)){

  if(spe == 1){shock = -1/10} # Shift -10%
  if(spe == 2){frac = 0} # Constant
  if(spe == 3){frac = .5} # Half growth

  # Re initialize result data frame
  result = result[0,] %>% data.frame()
    
  # Prepare data
  data = data_base %>% 
    # No biased technical change
    mutate(AK = 1, AL = 1) %>% 
    # Add parameters
    merge(param) %>% 
    # Demography
    demo_changer(break_year = break_year, p1_equals_p_fix = FALSE) %>% 
    # Define specification model
    mutate(Specification = spe) %>%
    # Reorder variables
    select(Specification, everything())
  
  ## Modification of demographic data
  # Shift -10% scenario
  if(spe == 1){
  data = data %>% 
    group_by(Country, Sequence) %>% 
    mutate(
      # New p, p1 and n
      p.new = ifelse(Year > break_year, p*(1+shock), p),
      p1.new = ifelse(Year > break_year, p1*(1+shock), p1),
      n.new = ifelse(Year %in% first_years, n*(1-shock), n),
      
      p_fix = NA,
      p1_to_p_dist = NA,
      shock = shock,
      )
  }
  # Constant and half growth scenario
  if(spe %in% c(2,3)){
  data = data %>% 
    group_by(Country, Sequence) %>% 
    # Merge with break year
    merge(., data_base %>% subset(Year == break_year) %>% 
            select(Country, p_fix = p), by = "Country") %>% 
    mutate(
      p1_to_p_dist = p1 - p,
      # New p and p1
      p.new = ifelse(Year > break_year, frac*(p-p_fix) + p_fix, p),
      p1.new = ifelse(Year > break_year & Period < 3, dplyr::lead(p.new,1),
                      ifelse(Period == 3, p.new + p1_to_p_dist*frac, p1)),
      # Scale for the affected periods
      shock = (p.new - p)/p
      )
  }
  
  # Remaining demographic variables that are affected by the change
  data = data %>% 
    mutate(
      # New n
      n.new = ifelse(Year %in% first_years, n*(1-shock), n),
      # Compute Ny and No for the affected periods
      Ny.new = ifelse(Year %in% first_years, Ny*(1-shock), NA),
      No.new = ifelse(Year %in% first_years, No*(1+shock), NA),
      # Compute Ny and No for last sequence/periods
      Ny.new = ifelse(Year > max(first_years), lag(Ny.new,1)*n, Ny.new),
      No.new = ifelse(Year > max(first_years), lag(Ny.new,1)*p.new, No.new),
      # Recompute eta
      eta.new = n.new/p.new*(1+alpha*p1.new)*omega,
      # Replace values
      Ny = ifelse(is.na(Ny.new), Ny, Ny.new),
      No = ifelse(is.na(No.new), No, No.new),
      n = n.new,
      p = p.new,
      p1 = p1.new,
      eta = eta.new
      ) %>% 
    select(Specification, Country, Year, Sequence, Period, Ny, No, n, p, p1, 
           eta, everything(), -contains("new"), ) %>%
    ungroup()
  
  
  # Simulate the model for each country
  for(country in CountrySet){
    result = data %>%
    subset(Country == country) %>% 
    model2(time = 3) %>% 
    rbind(result, .)
  }
  
  # Remove duplicates
  list.sim$retage = rbind(list.sim$retage, result)
}

```

Figure \@ref(fig:graph-retage-p) shows the survival rate dynamics with changing retirement age specifications. This figure corresponds to Figure 9 in the paper.

```{r graph-retage-p}
## Survival rate dataframe
list.graph$retage_p = list.sim$retage[,-c({ncol(list.sim$retage)-2}:ncol(list.sim$retage))] %>%
  rbind(list.sim$benchmark) %>% 
  select(Specification, Country, Year, p, p1) %>% setDT %>% 
  melt(id.vars = c("Specification" ,"Country", "Year")) %>% 
  subset(Year >= 2020) %>% 
  mutate(Specification = factor(Specification, levels = c("benchmark", 1:3), 
    labels = c("Benchmark", "Shift -10%", "Constant", "Half growth"))) %>% 
  
  ggplot(aes(x = Year, y = value)) +
  facet_wrap(Country ~ ., scales = "fixed") +
  theme_bw() +
  theme(legend.position = "right", legend.text.align = 0, panel.spacing.x = unit(1, "lines")) +
  scale_x_continuous(breaks = seq(2020, 2080, 10), labels = c("2020", "", "2040", "", "2060", "", "2080")) +
  labs(x = element_blank(), y = element_blank(), linetype = "Scenario", color = "Survival rate", title = element_blank()) +
  guides(linetype = guide_legend(order = 2), color = guide_legend(order = 1))

# Paper version
list.graph$retage_p +
  geom_line(aes(linetype = Specification, color = variable)) +
  
  scale_linetype_manual(values = c("solid", "dashed", "dotdash", "dotted")) +
  scale_color_grey(start = 0, end = .5, labels = c(expression(p[t]), expression(p[t+1]))) +
  ggsave(file.path(loc_graphic, "discuss-retage-p.png"), width = 7, height = 7/2.5)

# Color version
list.graph$retage_p +
  geom_line(aes(linetype = variable, color = Specification)) +
  
  scale_linetype_manual(values = c("solid", "dashed"), labels = c(expression(p[t]), expression(p[t+1]))) +
  scale_color_manual(values = c("black", brewer.pal(8, "Set1")[c(1:3)])) 
  ggsave(file.path(loc_graphic, "discuss-retage-p-color.png"), width = 7, height = 7/2.5)

```


Figure \@ref(fig:graph-retage-ls) shows the survival rate dynamics with changing retirement age specifications. This figure corresponds to Figure 10 in the paper.

```{r graph-retage-ls}
## Dataframe for the labor share
list.graph$retage_ls = list.sim$retage[,-c({ncol(list.sim$retage)-2}:ncol(list.sim$retage))] %>%
  rbind(list.sim$benchmark) %>% 
  select(Specification, Country, Year, theta) %>% setDT %>% 
  melt(id.vars = c("Specification" ,"Country", "Year")) %>% 
  subset(Year >= 2020) %>% 
  mutate(Specification = factor(Specification,
    levels = c("benchmark", 1:3),
    labels = c("Benchmark", "Shift -10%", "Constant", "Half growth"))) %>% 
  
  ggplot(aes(x = Year, y = value, linetype = Specification, color = Specification)) +
  geom_line() +
  facet_wrap(Country ~ ., scales = "fixed") +
  scale_x_continuous(breaks = seq(2020, 2080, 10), labels = c("2020", "", "2040", "", "2060", "", "2080")) +
  theme_bw() +
  theme(legend.position = "bottom", legend.text.align = 0) +
  labs(x = element_blank(), y = "Labor share", linetype = "Scenario", color = "Scenario", title = element_blank())

# Paper version
list.graph$retage_ls +
  
  scale_color_manual(values = rep("black", 4)) +
  scale_linetype_manual(values = c("solid", "dashed", "dotdash", "dotted")) +
  ggsave(file.path(loc_graphic, "discuss-retage-ls.png"), width = 7, height = 7/1.5)

# Color version
list.graph$retage_ls +
  
  scale_color_manual(values = c("black", brewer.pal(8, "Set1")[c(1:3)])) +
  scale_linetype_manual(values = c("solid", rep("dashed", 3))) +
  ggsave(file.path(loc_graphic, "discuss-retage-ls-color.png"), width = 7, height = 7/1.5)

```

# Uniqueness of the equilibrium

This section provides the details of the uniqueness of the equilibrium in the paper (appendix). Figure \@ref(fig:graph-uniq-gshape) shows the shapes of the g function. This figure corresponds to Figure 11 in the paper (appendix).

```{r graph-uniq-gshape, warning=F}
# Define the g function
g = function(k, sigma, ks){
  k1 = ks[1]
  k2 = ks[2]
  G = log((k/k1-1)/((k/k2)^((sigma-1)/sigma)-1))
  return(G)
}

# Create a dataframe with only x values
df.inter = data.frame("inter" = seq(0, 6, length.out = 10000))

# 4 cases
sigmas = c(0.8, 1.2)
ks = list(c(1, 2), c(2,1))

# Empty dataframe
df.g = data.frame(matrix(nrow = 0, ncol = 4)) %>% 
  setNames(c("inter", "sigma", "k_type", "g"))

# Loop
for(ss in 1:length(sigmas)){
  for(kk in 1:length(ks)){
    
  df.g = df.inter %>% 
    mutate(sigma = sigmas[ss], k_type = kk) %>% 
    mutate(g = g(inter, sigma, ks[[kk]])) %>% 
    rbind(df.g)
  }
}

# Figure
df.g %>% 
  
  filter(!((is.nan(g)|is.infinite(g)) & sigma == 0.8 & inter > 3)) %>%
  mutate(sigma = factor(sigma, labels = c('sigma~"<"~1','sigma~">"~1')),
         k_type = factor(k_type, labels = c('k[1]~"<"~k[2]', 'k[1]~">"~k[2]'))) %>%
  
  ggplot(aes(x = inter, y = g)) +
  geom_vline(xintercept = 1, color = "black", linetype = "dashed", alpha = 0.5) +
  geom_vline(xintercept = 2, color = "black", linetype = "dashed", alpha = 0.5) +
  geom_line() +
  facet_grid(k_type ~ sigma , scales = "free_x", labeller = label_parsed) +
  scale_x_continuous(breaks = c(0, 1, 2), 
                     labels = c(0, "", ""), expand = c(0,0)) +
  scale_y_continuous(name = "", breaks = 0, labels = 0, expand = c(0,0)) +
  labs(x = element_blank(), y = element_blank()) +
  theme_bw() +
  ggsave(file.path(loc_graphic, "uniq-gshape.png"), width = 7, height = 7/1.5)
```

Figure \@ref(fig:graph-uniq-hshape) shows the shapes of the h function. This figure corresponds to Figure 12 in the paper (appendix).

```{r graph-uniq-hshape}
# Define h function
h = function(k, sigma, phi, gamma){
  H = (sigma + (1-phi)/phi * (1-gamma*(1-sigma))/gamma * k^((1-sigma)/sigma))^(-1)
  return(H)
}

# Create a dataframe with only x values
df.inter = data.frame("inter" = seq(0, 1, length.out = 10000))

# 3 cases
sigmas = c(0.25, 0.8, 1.2)
phi = 0.3 # Average value of phi for France and the United-States
gamma = 0.5 # Value from calibration

# Empty dataframe
df.h = data.frame(matrix(nrow = 0, ncol = 4)) %>% 
  setNames(c("inter", "sigma", "k_type", "g"))

# Loop
for(ss in 1:length(sigmas)){
  
  df.h = df.inter %>% 
    mutate(sigma = sigmas[ss]) %>% 
    mutate(h = h(inter, sigma, phi, gamma)) %>% 
    rbind(df.h)
}

# Figure
df.h %>% 
  mutate(h_rescale = h*sigma) %>% 
  
  filter(inter < 1) %>%
  mutate(sigma = factor(sigma, labels = c('sigma~"<"~0.5','0.5~"<"~sigma~"<"~1',
                                          'sigma~">"~1'))) %>% 
  
  ggplot(aes(x = inter, y = h_rescale)) +
  geom_hline(yintercept = 1, color = "black", linetype = "dashed", alpha = 0.5) +
  geom_line() +
  facet_grid(. ~ sigma , scales = "free_x", labeller = label_parsed) +
  scale_x_continuous(breaks = 0, labels = 0, expand = c(0,0)) +
  scale_y_continuous(breaks = c(0, 1), labels = c(0, expression(frac(1,sigma))), 
                     limits = c(0, 1.05), expand = c(0,0)) +
  labs(x = element_blank(), y = element_blank()) +
  theme_bw() +
  ggsave(file.path(loc_graphic, "uniq-hshape.png"), width = 7, height = 7/2.5)
```

Figure \@ref(fig:graph-uniq-rho01) shows the numerical simulation of $g(\tilde{k}_t)$ and $g(\tilde{k}_t)$, when both input factors are gross substitute, i.e. $\sigma > 1$ or $\rho \in (0,1)$. This figure corresponds to Figure 12 in the paper (appendix).

```{r graph-uniq-rho01, warning = F}
# Ranges
sigma_range = c(1.1, 1.2, 1.3, 1.5, 1.7)
k1 = 1
k2_range = k1*c(0.3, 0.6, 0.9, 1.1, 1.4, 1.7)
gamma = 0.5
phi = 0.3

# Interval
inter = seq(0.001, 30, 0.001)

# Empty data frame
result = data.frame(matrix(ncol = 4, nrow = 0)) %>% 
  setNames(c("inter", "sigma", "k2", "value"))

# Loop to compute g function
for(k2 in k2_range){
  for(sigma in sigma_range){
   
   g = function(k, sigma, k1, k2){
      G = log((k/k1-1)/((k/k2)^((sigma-1)/sigma)-1))
      return(G)
   }
   
   h = function(k, sigma, k1, phi, gamma){
     H = (sigma + (1-phi)/phi*(1-gamma*(1-sigma))/gamma*k^((1-sigma)/sigma))^(-1)
     return(H)
   }
   
   # Cbind
   result = cbind(inter, sigma, k2, "value" = g(inter, sigma, k1, k2),
                  "value_h" = h(inter, sigma, k1, phi, gamma)) %>% 
     rbind(result)
  }
}

# Regroup and set factor
result1 = as.data.frame(result) %>% 
   mutate(
     rho = (sigma-1)/sigma,
     bound = 1/sigma,
     violation = ifelse(bound > value, TRUE, FALSE),
     h_over_g = ifelse(value < value_h, TRUE, FALSE),
     k2 = as.character(k2),
     sigmarho = paste0(sigma, " (",round(rho, 2),")"),
   )

# After the asymptotes
result_after = result1 %>% subset(inter > as.numeric(k2))
# Before the asymptotes
result_before = result1 %>% subset(inter <= as.numeric(k2))

# Show minimum k on (k2, +infinity)
min_val = result_after %>%  
  group_by(sigmarho, k2) %>% 
  summarise(min(value), min(bound)) %>% 
  setNames(c("sigmarho", "k2", "min_k", "min_x"))

x_bound = min_val %>% pull("min_x")

## Figure
graph_uniq_rho01 = result1 %>%
  
  ggplot(aes(x = inter, color = sigmarho)) +
  # g function
  geom_line(aes(y = value)) +
  # h function
  geom_line(aes(y = value_h), linetype = "dashed") +
  # Limit in +infinity of the h function
  geom_hline(data = min_val, aes(yintercept = x_bound, color = sigmarho), linetype = "dotted") +
  # Wrap
  facet_wrap(k2 ~ ., labeller = label_bquote(nu == .(k2))) +
  # Axis
  scale_x_continuous(breaks = 0, limits = c(0, 3), expand = c(0,0)) +
  scale_y_continuous(breaks = c(0,1), limits = c(0, 3), expand = c(0,0)) +
  # Graphic parameters
  theme_bw() + theme(legend.position = "right") + labs(x = element_blank(), y = element_blank())

# Paper version
graph_uniq_rho01 +
  scale_color_grey(name = bquote(sigma~(rho)), start = 0, end  = .8) +
  ggsave(file.path(loc_graphic, "uniq-rho01.png"), width = 7, height = 7/1.5)

# Color version
graph_uniq_rho01 +
  scale_color_manual(name = bquote(sigma~(rho)), values = brewer.pal(8, "Set1")) +
  ggsave(file.path(loc_graphic, "uniq-rho01-color.png"), width = 7, height = 7/1.5)
```

# Estimation of the capital-labor elasticity

This section provides the details of the estimation of the capital-labor elasticity in the paper (appendix). As in the calibration section above, I detail the estimation of the elasticity with the detailed methodology.

```{r sigma-data}
# Variable from PWT
pwt1 = pwt %>%
  subset(Year %in% c(1970:2010)) %>% 
  group_by(Country) %>% 
  mutate(L = emp * 1000, # Labor
         K = rnna * 1000, # Capital
         K.avh = rnna / avh * 1000, # Capital // AVH control
         theta1 = lab_sh1, # Labor share // Adjustment 1
         theta2 = lab_sh2, # Labor share // Adjustment 2
         ) %>% 
  select(Country, Year, avh, L, K, K.avh, theta1, theta2) %>% 
  mutate(avh = avh / first(avh), # Normalized avh
         L = L / first(L), # Normalized labor
         K = K / first(K), # Normalized capital
         K.avh = K.avh / first(K.avh), # Normalized capital // AVH Control
         k = K / L, # Normalized capital-labor ratio
         k.avh = K.avh / L, # Normalized capital-labor ratio // AVH Control
         ) %>% # Normalized old population
  ungroup() %>% 
  # Remove unused countries from Country levels
  mutate(Country = factor(Country))

# Treatment
pwt2 = pwt1 %>% 
  group_by(Country) %>% 
  mutate(
         # Compute the income ratio
         THETA1 = theta1/(1-theta1),
         THETA2 = theta2/(1-theta2),
         THETA1.avh = THETA1*avh,
         THETA2.avh = THETA2*avh,
         # Logarithm
         THETA1_log = log(THETA1),
         THETA2_log = log(THETA2),
         THETA1.avh_log = log(THETA1.avh),
         THETA2.avh_log = log(THETA2.avh),
         k_log = log(k),
         k.avh_log = log(k.avh),
         # Time trend
         t_diff = Year - first(Year)) %>% 
  ungroup %>% 
  subset(Country %in% c("France", "United States"))

# Preview
head(pwt2)
```

```{r sigma-reg}
# Empty list
reg = list()

# Coefficients
coef.map = list("(Intercept)" = "$\\alpha$", "k_log" = "$\\beta$", "k.avh_log" = "$\\beta$", "t_diff" = "$\\gamma$")

## Regressions
# France
# (RAW) column
reg$FRraw = lm(formula = THETA1_log ~ k_log, data = pwt2, subset = Country =="France")
# (HWC) column
reg$FRhwc = lm(formula = THETA1_log ~ k.avh_log, data = pwt2, subset = Country =="France")
# (BTC) column
reg$FRbtc = lm(formula = THETA1_log ~ k_log + t_diff, data = pwt2, subset = Country =="France")
# (HWC-BTC) column
reg$FRboth = lm(formula = THETA1_log ~ k.avh_log + t_diff, data = pwt2, subset = Country =="France")
# United States
# (RAW) column
reg$USraw = lm(formula = THETA1_log ~ k_log, data = pwt2, subset = Country =="United States")
# (HWC) column
reg$UShwc = lm(formula = THETA1_log ~ k.avh_log, data = pwt2, subset = Country =="United States")
# (BTC) column
reg$USbtc = lm(formula = THETA1_log ~ k_log + t_diff, data = pwt2, subset = Country =="United States")
# (HWC-BTC) column
reg$USboth = lm(formula = THETA1_log ~ k.avh_log + t_diff, data = pwt2, subset = Country =="United States")

```

Compute the elasticity for all the specifications.

```{r sigma-compute}
## Compute sigma
sigma = c(1/(1+reg$FRraw$coefficients["k_log"]),
             1/(1+reg$FRhwc$coefficients["k.avh_log"]),
             1/(1+reg$FRbtc$coefficients["k_log"]),
             1/(1+reg$FRboth$coefficients["k.avh_log"]),
             1/(1+reg$USraw$coefficients["k_log"]),
             1/(1+reg$UShwc$coefficients["k.avh_log"]),
             1/(1+reg$USbtc$coefficients["k_log"]),
             1/(1+reg$USboth$coefficients["k.avh_log"])
          ) %>% unname() %>% round(3)
```

Table \@ref(tab:tab-sigma-estimate) summarizes the parameters for both countries. This table corresponds to Table 3 in the paper (appendix).

```{r tab-sigma-estimate}
# Table from regressions with siglma
tabular(reg, coef_map = coef.map,
        gof.row = list("$\\sigma$" = sigma),
        digits = 3,
        model_map = rep(c("(RAW)", "(HWC)", "(BTC)", "(HWC-BTC)"),2),
        group.models = list("France" = 1:4, "United States" = 5:8),
        reg.type = "Linear regression") %>% 
  writeLines(., con = "_tabular/sigma-estimate.tex")
```

# Two capital-labor elasticity regimes in France

This section provides the details of the two capital-labor elasticity regimes for France in the paper (appendix). Figure \@ref(fig:graph-regime-detrend) shows raw and detrended data of the capital-per-worker and the labor-to-capital income ratio in France between 1970 and 2010. This figure corresponds to Figure 13 in the paper (appendix).

```{r graph-regime-detrend, warnings = FALSE}
# Select France
pwt2.fr = subset(pwt2, Country == "France")

# Detrend k
pwt2.fr$k.avh_log_detrend = pwt2.fr %>% 
  lm(k.avh_log ~ t_diff, data = .) %>%
  residuals()

# Detrend THETA
pwt2.fr$THETA1_log_detrend = pwt2.fr %>% 
  lm(THETA1_log ~ t_diff, data = .) %>%
  residuals()

## Core
list.graph$regime_detrend = pwt2.fr %>% 
  select(Country, Year, k.avh_log, THETA1_log, k.avh_log_detrend, THETA1_log_detrend) %>% 
  setDT %>% melt(id.vars = c("Country", "Year")) %>% 
  mutate(type = factor(variable, labels = c("raw", "raw", "detrend", "detrend")),
         var = factor(variable, labels = c("k", "THETA", "k", "THETA"))) %>% 
  
  ggplot(aes(x = Year, y = value, color = var, linetype = var)) +
  geom_line() +
  geom_vline(xintercept = 1985, linetype = "dotted", color = "black") +
  facet_wrap(. ~ type, scales = "free", labeller = labeller(type = c(raw = "Raw data", detrend = "Detrended data"))) +
  theme_bw() +
  labs(x = element_blank(), y = element_blank(), color = element_blank(), linetype = element_blank()) +
  theme(legend.position = "bottom")

## Paper version
list.graph$regime_detrend +
  scale_color_grey(start = 0, end = 0,
    labels = c("Normalized capital-per-worker (in log)", "Labor-to-capital income ratio (in log)")) +
  scale_linetype_manual(values = c("solid", "dashed"),
    labels = c("Normalized capital-per-worker (in log)", "Labor-to-capital income ratio (in log)")) +
  ggsave(file.path(loc_graphic, "regime-detrend.png"), width = 7, height = 7/2)

## Color version
list.graph$regime_detrend +
  scale_color_manual(values = brewer.pal(8, "Set1"),
    labels = c("Normalized capital-per-worker (in log)", "Labor-to-capital income ratio (in log)")) +
  scale_linetype_manual(values = c("solid", "solid"),
    labels = c("Normalized capital-per-worker (in log)", "Labor-to-capital income ratio (in log)")) +
  ggsave(file.path(loc_graphic, "regime-detrend-color.png"), width = 7, height = 7/2)

```

Figure \@ref(fig:graph-regime-regline) shows the regression lines of the labor-to-capital income ratio explained by the normalized capital-per-worker, both in logs with raw and detrended data over the two periods.

```{r graph-regime-regline}
## Core
list.graph$regime_regline = pwt2.fr %>% 
  select(Country, Year, k_raw = k.avh_log, THETA_raw = THETA1_log, 
         k_detrend = k.avh_log_detrend, THETA_detrend = THETA1_log_detrend) %>% 
  setDT %>% 
  melt(id.vars = c("Country", "Year")) %>% 
  tidyr::separate(variable, c("var", "type")) %>% 
  dcast.data.table(Country + Year + type ~ var, value.var = "value") %>% 
  mutate(before_break = factor(ifelse(Year <= 1985, "1970-1985", "1986-2010")),
         type = factor(type, levels = c("raw", "detrend"))) %>% 
  
  ggplot(aes(x = k, y = THETA, color = before_break, shape = before_break)) +
  geom_point(size = 2) +
  stat_smooth(method = "lm", alpha = 0.2) +
  facet_wrap(type ~ ., scale = "free",
    labeller = labeller(type = c(raw = "Raw data", detrend = "Detrended data"))) +
  theme_bw() +
  labs(x = "Normalized capital-per-worker (in log)", y = "Labor-to-capital income ratio (in log)", color = element_blank(), shape = element_blank()) +
  theme(legend.position = "bottom")

## Paper version
list.graph$regime_regline +
  scale_color_grey(start = 0.1, end = 0.5) +
  scale_shape_manual(values = c(16, 17)) +
  ggsave(file.path(loc_graphic, "regime-regline.png"), width = 7, height = 7/2)

## Color version
list.graph$regime_regline +
  scale_color_manual(values = brewer.pal(8, "Set1")[c(3,4)]) +
  scale_shape_manual(values = c(16, 17)) +
  ggsave(file.path(loc_graphic, "regime-regline-color.png"), width = 7, height = 7/2)
```

Estimate the optimal break point. Find that the optimal break is in 1985. Wald test rejects the null hypothesis.

```{r find-breakpoint}
# Required packages
require(strucchange)
require(lmtest)

## Base model as in (HWC-BTC) from Appendix C
m0 = lm(THETA1_log_detrend ~ k.avh_log_detrend, data = pwt2.fr)
## Estimate the optimal break point
mbp = breakpoints(THETA1_log_detrend ~ k.avh_log_detrend, data = pwt2.fr, breaks = 1)
# Optimal break
break_year = pwt2.fr$Year[mbp$breakpoints]
break_year

## Model with 1 breakpoint
m1 = lm(THETA1_log_detrend ~ k.avh_log_detrend*I(Year<=1985), data = pwt2.fr)

## WALD TEST to compare both
waldtest(m1, m0)
```
I run the regressions with break year in 1985.

```{r reg-breakpoint}
# Empty list
reg2 = list()
# Coefficients
coef.map2 = list("(Intercept)" = "$\\alpha$", "k.avh_log" = "$\\beta$", "t_diff" = "$\\gamma$")

# Regressions
reg2$p1_hwc = lm(formula = THETA1_log ~ k.avh_log, data = pwt2.fr, subset = Year <= break_year)
reg2$p1_both = lm(formula = THETA1_log ~ k.avh_log + t_diff, data = pwt2.fr, subset = Year <= break_year)
reg2$p2_hwc = lm(formula = THETA1_log ~ k.avh_log, data = pwt2.fr, subset = Year > break_year)
reg2$p2_both = lm(formula = THETA1_log ~ k.avh_log + t_diff, data = pwt2.fr, subset = Year > break_year)

## Compute sigma for France
sigma2 = c(1/(1+reg2$p1_hwc$coefficients["k.avh_log"]),
             1/(1+reg2$p1_both$coefficients["k.avh_log"]),
             1/(1+reg2$p2_hwc$coefficients["k.avh_log"]),
             1/(1+reg2$p2_both$coefficients["k.avh_log"])
             ) %>% unname()
# Round
sigma2 = lapply(sigma2, function(x){round(x, 3)})
```

Table \@ref(tab:tab-regime-estimate) summarizes the parameters for France wit a break in the regime in 1985. This table corresponds to Table 5 in the paper (appendix).

```{r tab-regime-estimate}
tabular(reg2, coef_map = coef.map2,
        gof.row = list("$\\sigma_{FR}$" = c(sigma2)),
        digits = 3,
        group.models = list("1970-1985" = 1:2, "1986-2010" = 3:4),
        model_map = c("(HWC)", "(HWC-BTC)", "(HWC)", "(HWC-BTC)"),
        reg.type = "Linear regression") %>% 
  writeLines(., con = "_tabular/regime-estimate.tex")
```
