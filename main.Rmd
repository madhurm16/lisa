---
title: "Labor Share & Aging Population"
author: "Fabien Petit"
output: github_document
---

## Data

```{r Initialization, include = FALSE}

# Define paths
loc_result = file.path(getwd(), "result")
loc_function = file.path(getwd(), "function")
loc_final = file.path(getwd(), "data", "final")

# Load packages
packages <- c("bucky", "dplyr", "ggplot2", "ggrepel", "lmtest", "sandwich", "zoo", "RColorBrewer", "reshape2")
lapply(packages, require, character.only = TRUE)
rm(packages)

# Load functions
sapply(list.files(pattern = "[.]R$", path = loc_function, full.names = TRUE), source)

```

```{r Simulation specification}

# Country set
country_set = c("France", "United States")

# Simulation periods
sim = seq(1970, 2080, 10)

# Estimation sample
est_sample = c(1970:2010)

```


```{r Load data}

# Penn World Table
pwt = read.csv(file.path(loc_final, "pwt.csv"), header = TRUE) %>%
  select("Country", "Year", "emp", "avh", "rgdpna", "rnna", "lab_sh1") %>% 
  subset(Country %in% country_set & Year >= 1970)

# OECD data
oecd = read.csv(file.path(loc_final, "oecd.csv"), header = TRUE) %>% 
  select("Country", "Year", tax_rate = "tax_rev_PC_GDP", union_density = "union_density.lin_inter", union_coverage = "union_coverage.lin_inter") %>% 
  subset(Country %in% country_set & Year >= 1970)

# Demographic data
demo = read.csv(file.path(loc_final, "demo.csv"), header = TRUE) %>% 
  select("Country", "Year", "young", "old", "dep", "n", "p") %>% 
  subset(Country %in% country_set & Year >= 1970)

## Merge
df = merge(merge(pwt, oecd, all = TRUE), demo, all = TRUE)

```


```{r Data retreatment}

# Variable modifications
df = df %>%
  group_by(Country) %>% 
  mutate(L = emp * 1000,
         Y = rgdpna / avh * 1000, # AVH control
         K = rnna / avh * 1000, # AVH control
         theta = lab_sh1, # Labor share
         tau = tax_rate / 100, # Tax rate
         u = 1 - L / young, # Unemployment rate
         p1 = lead(p, 40)) %>% 
  select(Country, Year, Ny = young, No = old, n, p, p1, dep, K, L, Y, theta, tau, u) %>% 
  mutate(L = L / first(L), # Normalized labor
         K = K / first(K), # Normalized capital
         Y = Y / first(Y), # Normalized output
         k = K / L, # Normalized capital-labor ratio
         Ny = L / (1-u), # Normalized young population
         No = Ny * dep) # Normalized old population

# Visualization
head(df)

```

## Parameter calibration

```{r Parameter - Dataframe, include = FALSE}

param_base = data.frame("Country" = rep(c("France", "United States"), each = length(sim)),
                   "Year" = sim,
                   "phi" = NA, "sigma" = NA, "a" = NA, "alpha" = (0.99)^40, "gamma" = NA, "omega" = NA, "beta" = NA, A = NA)

```

### Production function

```{r Parameter - Production function, echo = FALSE}

# Estimation
ols_sigma = df %>% 
  group_by(Country) %>% 
  mutate(k_log = log(k),
         THETA_log_neg = - log((1-theta)/theta),
         t_diff = Year - first(Year) + 1) %>% 
  select(Country, Year, k_log, THETA_log_neg, t_diff) %>% 
  subset(Year %in% c(1970:2010)) %>% 
  ungroup() %>% 
  lm(k_log ~ Country + THETA_log_neg*Country + t_diff*Country - THETA_log_neg - t_diff, data = .)

# Result visualization
robust.summary(ols_sigma)

# Add production function parameters
param_base = param_base %>% mutate("phi" = rep(1 - df$theta[df$Year == 1970], each = length(sim)),
                 "sigma" = rep(1 / (1 + ols_sigma$coefficients[c((length(country_set)+1):(2*length(country_set)))]), each = length(sim)),
                 "a" = rep(ols_sigma$coefficients[c((2*length(country_set)+1):(3*length(country_set)))], each = length(sim)))


```

### Wage bargaining

I create 4 different specifications of the relative bargaining power of the union.

* *gamma.cst* : Constant value of 0.5. This specification will be used for prediction.
* *gamma0* : Proxy of the bargaining power. It depends on the trade union density and the collective union coverage. I use a square root function to have a concave function of both variables and smooth the variations in bargaining power.
* *gamma1* : Rescale gamma0 such that gamma1 = 0.5 in 1970.
* *gamma2* : Rescale gamma0 such that mean(gamma2) = 0.5.

Both last specifications will be used to improve the quality of the fit on the period 1970 - 2010. Only the first specification will be used for prediction.

```{r Parameter - Bargaining power}

## Generate different specifications for bargaining power
param.gamma = oecd %>% 
  # subset(Year %in% sim) %>% 
  group_by(Country) %>% 
  mutate(gamma.cst = 0.5,
         gamma0 = sqrt(union_density*union_coverage),
         gamma1 = gamma0 / first(gamma0) * gamma.cst, # Rescale gamma such that gamma = 0.5 in 1970
         gamma2 = gamma0 / mean(gamma0, na.rm = TRUE) * gamma.cst) %>% # Rescale gamma such that gamma is normalize to its average value on the estimated sample
  merge(param_base[, c("Country", "Year")], ., all.x = TRUE) %>% 
  select(Country, Year, starts_with("gamma")) %>% 
  mutate(gamma.cst = 0.5)

param.gamma

```

### Preferences

```{r Parameter - Preferences}

## Generate different parameter values according to the value of gamma
param.pref = df %>%
  subset(Year == 1970) %>% 
  merge(param_base %>% select(Country, Year, phi, sigma, a, alpha), .) %>% 
  merge(param.gamma %>% select(Country, Year, gamma.cst, gamma0, gamma1, gamma2), .) %>% 
  mutate(## Variable : X for each gamma specification
         X.cst = (sigma + (1-phi)/phi*(1-gamma.cst*(1-sigma))/gamma.cst)^(-1),
         X0 = (sigma + (1-phi)/phi*(1-gamma0*(1-sigma))/gamma0)^(-1),
         # X1 is the same as X.cst since gamma1 = 0.5 in 1970
         X2 = (sigma + (1-phi)/phi*(1-gamma2*(1-sigma))/gamma2)^(-1),
         
         ## Parameter : OMEGA
         omega.cst = phi/(1-phi)*n/p*(1+alpha*p1)/(1 + exp(-X.cst)*(Ny - 1)),
         omega0 = phi/(1-phi)*n/p*(1+alpha*p1)/(1 + exp(-X0)*(Ny - 1)),
         # omega1 is the same as omega.cst since gamma1 = 0.5 in 1970
         omega2 = phi/(1-phi)*n/p*(1+alpha*p1)/(1 + exp(-X2)*(Ny - 1)),
         
         ## Variable : ETA
         eta.cst = n/p*(1+alpha*p1)/omega.cst,
         eta0 = n/p*(1+alpha*p1)/omega0,
         # eta1 is the same as X.cst since gamma1 = 0.5 in 1970
         eta2 = n/p*(1+alpha*p1)/omega2,
         
         ## Parameter : BETA
         beta.cst = 1/(1 - tau)/phi - 1 - eta.cst,
         beta0 = 1/(1 - tau)/phi - 1 - eta0,
         # beta1 is the same as omega.cst since gamma1 = 0.5 in 1970
         beta2 = 1/(1 - tau)/phi - 1 - eta2
         ) %>% 
  select(Country, starts_with("omega"), starts_with("beta")) %>% 
  merge(param_base[, c("Country", "Year")], ., all.x = TRUE)

# Visualization
param.pref %>% subset(Year ==  1970) %>% select(-Year)

```

## Simulation

```{r Simulation parameters specification}

init_seq = seq(1970, 2000, 10)

# Baseline data
data_base = df %>% group_by(Country) %>% subset(Year %in% sim) %>% select(Country, Year, Ny, No, n, p, p1, K) %>% 
  mutate(Sequence = ((sim- 1970)/10)%%4+1,
         Period = (sim-init_seq)/40+1,
         Ny = ifelse(Year == 2010, NA, Ny),
         No = ifelse(Year == 2010, NA, No),
         K = ifelse(Year == 2010, NA, K),
         p1 = ifelse(Year >= 2070, p1[Year == 2060] + (Year - 2060)/10 * mean(p1/lag(p1)-1, na.rm = TRUE), p1), # Complete NA values for p1 in 2070 and 2080
         ## Create empty variables
         eta = NA, AK = NA, AL = NA, k1 = NA, k2 = NA, k = NA, X = NA, L = NA, w = NA, Y = NA, u = NA, theta = NA, tau = NA, b = NA, h = NA, S = NA) 

# Re-order variables
data_base = data_base %>% select(Country, Year, Sequence, Period, Ny, No, n, p, p1, eta, AK, AL, k1, k2, k, X, L, w, Y, u, theta, tau, b, h, S, K)
  
# Visualization
head(data_base)

```


### Replicate data

```{r Define data and parameters}

# Prepare base datasets
data = data_base
param = param_base

## Choose a gamma specification
gamma_specification = ".cst"

param[,"gamma"] = param.gamma %>% select(gamma = paste0("gamma", gamma_specification))
param[,c("omega", "beta")] =  param.pref %>%
  select(omega = paste0("omega", gamma_specification),
         beta = paste0("beta", gamma_specification))

## Merge param and data
data = merge(data, param)

```


```{r Demographic variables}

## Population dynamics
for(seq in 1:4){
  for(t in 2:3){
    # Young population dynamics
    data$Ny[data$Period == t & data$Sequence == seq] = data$Ny[data$Period == t-1 & data$Sequence == seq]*data$n[data$Period == t & data$Sequence == seq]
    # Old population dynamics
    data$No[data$Period == t & data$Sequence == seq] = data$Ny[data$Period == t-1 & data$Sequence == seq]*data$p[data$Period == t & data$Sequence == seq]
  }
}

## Compute eta
data$eta = data$n/data$p*(1+data$alpha*data$p1)/data$omega

## No biased technical change
data$AK = 1
data$AL = 1




```



```{r A Finder}

#### PUT IN FUNCTION

# Labor share to target
target = df %>% subset(Year == 2010) %>% select(Country, theta)

# Country selection
country = "United States"

data = data %>% subset(Country == country)
target = round(target$theta[target$Country == country],3)

# A finder
A_bound = c(1, 100)
precision = nchar(strsplit(as.character(target), "\\.")[[1]][2])

for (preci in c(0:precision)){
  
      A_interval = seq(A_bound[1], A_bound[2], by = 0.1^(preci))
      est = NA
      
      for(Ai in c(1:length(A_interval))){
        data$A = A_interval[Ai]
        est_add = model(2)
        est_add = est_add[est_add$Year == 2010, names(est_add) == "theta"]
        est = c(est, est_add)
      }
      
      est = est[-1]
      names(est) = A_interval
      dist = (est - target)^2
      A_bound = sort(as.numeric(c(names(dist)[dist == min(dist)], names(dist)[dist == min(dist[dist!=min(dist)])])))
}
A_answer = as.numeric(names(dist)[dist == min(dist)])[1]

```

































