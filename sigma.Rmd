---
title: "Capital-Labor elasticity of substitution"	
author: "Fabien Petit"	
date: "24/05/2019"	
output:	
  github_document:	
    pandoc_args: --webtex
---

```{r Init, include = FALSE}	

# Define required packages
require(dplyr) # The FAMOUS one
require(reshape2) # Reshape data frame
require(ggplot2) # Plot
require(bucky) # Robust standard errors
require(sandwich) # If you are hungry
require(RColorBrewer)

# Define paths
loc_final = file.path("data", "final")
loc_result_sigma = file.path("result", "sigma")

# Define country set
# country_set = c("Australia", "Canada", "France", "Italy", "Japan", "United States")
country_set = c("France", "United States")

# Graphic parameter
scale_graph = 1920/1080

```	

## Methodology

I estimate the elasticity of substitution between capital and labor using the methodology of **Leon-Ledesma, McAdam & Willman (2013)**. Estimation are done for France and United States between 1970 and 2010, using Penn World Table 9.1 data.

Following the methodology of Leon-Ledesma, McAdam & Willman (2013), I estimate the following equation :	
<center>
$$\ln \Theta_t = \alpha + \frac{1-\sigma}{\sigma} \ln k_t + \frac{1-\sigma}{\sigma} \left( a_K-a_L\right)t + \varepsilon_t$$
</center>
Therefore, I need to compute the capital-to-labor ratio $~k_t~$ and the capital-to-labor income ratio $~\Theta_t~$.

## Data

```{r Load Data, echo = FALSE}

# Penn World Table
pwt = read.csv(file.path(loc_final, "pwt.csv"), header = TRUE) %>%
  select("Country", "Year", "emp", "avh", "rgdpna", "rnna", "lab_sh1", "lab_sh2") %>% 
  subset(Country %in% country_set & Year >= 1970)

# OECD data
oecd = read.csv(file.path(loc_final, "oecd.csv"), header = TRUE) %>% 
  select("Country", "Year", tax_rate = "tax_rev_PC_GDP", union_density = "union_density.lin_inter", union_coverage = "union_coverage.lin_inter") %>% 
  subset(Country %in% country_set & Year >= 1970)

# Demographic data
demo = read.csv(file.path(loc_final, "demo.csv"), header = TRUE) %>% 
  select("Country", "Year", "young", "young_1564", "old", "dep", "n", "p") %>% 
  subset(Country %in% country_set & Year >= 1970)

## Merge
df = merge(merge(pwt, oecd, all = TRUE), demo, all = TRUE)

# Variable modifications
df = df %>%
  subset(Year %in% c(1970:2010)) %>% 
  group_by(Country) %>% 
  mutate(L = emp * 1000, # Labor
         K = rnna * 1000, # Capital
         K.avh = rnna / avh * 1000, # Capital // AVH control
         theta1 = lab_sh1, # Labor share // Adjustment 1
         theta2 = lab_sh2, # Labor share // Adjustment 2
         ) %>% 
  select(Country, Year, avh, L, K, K.avh, theta1, theta2) %>% 
  mutate(avh = avh / first(avh), # Normalized avh
         L = L / first(L), # Normalized labor
         K = K / first(K), # Normalized capital
         K.avh = K.avh / first(K.avh), # Normalized capital // AVH Control
         k = K / L, # Normalized capital-labor ratio
         k.avh = K.avh / L, # Normalized capital-labor ratio // AVH Control
         ) %>% # Normalized old population
  ungroup()

# Remove unused countries from Country levels
df$Country = df$Country %>% as.character %>% as.factor()

# Visualization
head(df)
 
```	

The variables from the **Penn World Table 9.1** are the following :	


* *emp* : Number of persons engaged (in millions)	
* *avh* : Average annual hours worked by persons engaged	
* *rnna* : Capital stock at constant 2011 national prices (in mil. 2011US$)	
* *lab_sh1* : Share of labour compensation in GDP at current national prices (**Adjustment method 1**)
* *lab_sh2* : Share of labour compensation in GDP at current national prices (**Adjustment method 2**)

```{r Compare both labor share, echo = FALSE}

df %>% select(Country, Year, theta1, theta2) %>% 
  melt(id.vars = c("Country", "Year")) %>% 
  ggplot(aes(x = Year, y = value, color = variable)) +
  scale_color_discrete(name = "Adjustment Method", breaks = c("lab_sh1", "lab_sh2"),
                       labels = c("1st", "2nd")) +
  geom_line(size = 0.5) +
  facet_wrap(Country ~ .) +
  labs(x = "Year", y = "Labor share") +
  theme_classic(base_size = 14) +
  theme(legend.direction = "horizontal", legend.position = "bottom")


```


I use the first adjustment method (see **Frenstra, Inklaar and Timmer 2015** and **Gollin 2002** for more details). An adjustment method is required to take into account self-employed income.

**Adjustment 1** adds mixed income (MIX) to the compensation of employees (COMP). Thus,
<center>
$$LS = \frac{COMP+MIX}{GDP}$$
</center>

**Adjustment 2** assumes the same labor share for mixed income as for the rest of the economy. Thus,
<center>
$$LS = \frac{COMP}{GDP-MIX}$$
</center>

In the model, workers are only young individuals and provide only labor supply. Therefore, I assume that self-employed people earn an income that is characterized as a compensation. Hence, I will use the first adjustment method. I normalize the capital-to-labor ratio to the initial year (i.e. 1970).

```{r Plot k_nor, echo = FALSE}

df %>% select("Country", "Year", "k", "k.avh") %>%
  melt(id.vars = c("Country", "Year")) %>%
  ggplot(aes(x = Year, y = value, color = variable)) +
  geom_line(size = .5) +
  facet_wrap(Country ~ .) +
  scale_color_discrete(name = "", breaks = c("k", "k.avh"),
                       labels = c("Standard", "AVH correction")) +
  labs(x = "Year", y = "Normalized capital-to-labor ratio (1970 = 1)") +
  theme_classic(base_size = 14) +
  theme(legend.direction = "horizontal", legend.position = "bottom")
  
```	

```{r Income ratio and logarithm, echo = FALSE}

df = df %>% 
  group_by(Country) %>% 
  mutate(THETA1 = theta1/(1-theta1),
         THETA2 = theta2/(1-theta2),
         THETA1.avh = THETA1*avh,
         THETA2.avh = THETA2*avh,
         # Logarithm
         THETA1_log = log(THETA1),
         THETA2_log = log(THETA2),
         THETA1.avh_log = log(THETA1.avh),
         THETA2.avh_log = log(THETA2.avh),
         k_log = log(k),
         k.avh_log = log(k.avh),
         # Time trend
         t_diff = Year - first(Year))

```

```{r Adjustment 1, eco = FALSE}

ols1.raw = df %>% 
  lm(formula = THETA1_log ~ Country + k_log*Country - 1 - k_log)
ols1.raw %>% summary()
sigma1.raw = 1/(1 + ols1.raw$coefficients[c(3,4)])

ols1.hwc = df %>% 
  lm(formula = THETA1_log ~ Country + k.avh_log*Country - 1 - k.avh_log)
ols1.hwc %>% summary()
sigma1.hwc = 1/(1 + ols1.hwc$coefficients[c(3,4)])

ols1.btc = df %>% 
  lm(formula = THETA1_log ~ Country + k_log*Country + t_diff*Country - 1 - k_log - t_diff)
ols1.btc %>% summary()
sigma1.btc = 1/(1 + ols1.btc$coefficients[c(3,4)])

ols1.both = df %>% 
  lm(formula = THETA1_log ~ Country + k.avh_log*Country + t_diff*Country - 1 - k.avh_log - t_diff)
ols1.both %>% summary()
sigma1.both = 1/(1 + ols1.both$coefficients[c(3,4)])

```

```{r Adjustment 2, echo = FALSE}

ols2.raw = df %>% 
  lm(formula = THETA2_log ~ Country + k_log*Country - 1 - k_log)
ols2.raw %>% summary()
sigma2.raw = 1/(1 + ols2.raw$coefficients[c(3,4)])

ols2.hwc = df %>% 
  lm(formula = THETA2_log ~ Country + k.avh_log*Country - 1 - k.avh_log)
ols2.hwc %>% summary()
sigma2.hwc = 1/(1 + ols2.hwc$coefficients[c(3,4)])

ols2.btc = df %>% 
  lm(formula = THETA2_log ~ Country + k_log*Country + t_diff*Country - 1 - k_log - t_diff)
ols2.btc %>% summary()
sigma2.btc = 1/(1 + ols2.btc$coefficients[c(3,4)])

ols2.both = df %>% 
  lm(formula = THETA2_log ~ Country + k.avh_log*Country + t_diff*Country - 1 - k.avh_log - t_diff)
ols2.both %>% summary()
sigma2.both = 1/(1 + ols2.both$coefficients[c(3,4)])

```

```{r Gather results, echo = FALSE, warning = FALSE}

data.frame(sigma1.raw, sigma1.hwc, sigma1.btc, sigma1.both,
           sigma2.raw, sigma2.hwc, sigma2.btc, sigma2.both)


```

## Break Year

The purpose of this section is to investigate whether there is a break in the estimated elasticity of substitution. In particular for France. Indeed, there capital-per-worker $k_t$ grows at a relatively constant rate while the labor share $\Theta_t$ faces a huge decrease during the 80's.

I consider only France with adjustment method 1 and capital with average hours worked correction. Estimation is done with biased technical change.

```{r Break Year - Graph 1, echo = FALSE}

df.fr = df %>% 
  ungroup() %>% 
  subset(Country == "France") %>% 
  select(- Country)

df.fr %>% 
  select(Year, k.avh_log, THETA1_log) %>% 
  melt(id.vars = "Year") %>% 
  
  ggplot(aes(x = Year, y = value, color = variable)) +
  geom_line() +
  geom_vline(xintercept = 1982, linetype = "dashed") +
  scale_color_manual(values = brewer.pal(8, "Set1")) +
  scale_x_continuous(breaks = c(1970, 1980, 1982, 1990, 2000, 2010),
                     labels = c(1970, "", 1982, 1990, 2000, 2010)) +
  theme_classic(base_size = 14) +
  labs(x = "", y = "") +
  theme(legend.position = "none") +
  ggsave(file.path(loc_result_sigma, "k_Theta_log.png"), width = scale_graph*5, height = scale_graph*5/2)

```
```{r Break Year - Correlation, echo = FALSE}

# 1982 included in before
df.fr %>% 
  mutate(period = ifelse(Year <= 1983, "before", "after")) %>% 
  group_by(period) %>% 
  summarise(cor(k.avh_log, THETA1_log))

# 1982 included in after
df.fr %>% 
  mutate(period = ifelse(Year < 1983, "before", "after")) %>% 
  group_by(period) %>% 
  summarise(cor(k.avh_log, THETA1_log))

```


This is the baseline regression, where I estimate the capital-labor elasticity of substitution for the whole sample. 

```{r Break Year - Baseline estimation, echo = FALSE}

ols_base = df.fr %>% 
  lm(THETA1_log ~ k.avh_log + t_diff, data = .)
robust.summary(ols_base)

sigma.fr_all = 1/(1+ols_base$coefficients[2]) %>% unname()
sigma.fr_all

```

There is a biased technical change, which is constant and significant. I have to keep the same rate of technical change. Because if I split the sample, I would obtain two different BTC growth rates. Thus, a way is to detrend the capital-per-worker and the capital-to-labor income ratio. Such a methodology comes from the **Frisch–Waugh–Lovell theorem**.


```{r Break Year - Detrend, echo = FALSE, warnings = FALSE}

# Detrend k
df.fr$k.avh_log_detrend = df.fr %>% 
  lm(k.avh_log ~ t_diff, data = .) %>%
  residuals()

# Detrend THETA
df.fr$THETA1_log_detrend = df.fr %>% 
  lm(THETA1_log ~ t_diff, data = .) %>%
  residuals()

# Plot detrended variables
df.fr %>% 
  select(Year, k.avh_log_detrend, THETA1_log_detrend) %>% 
  melt(id.vars = "Year") %>% 
  
  ggplot(aes(x = Year, y = value, color = variable)) +
  geom_line() +
  geom_vline(xintercept = 1982, linetype = "dashed") +
  geom_vline(xintercept = 1985, linetype = "dashed") +
  geom_vline(xintercept = 1989, linetype = "dashed") +
  scale_color_manual(values = brewer.pal(8, "Set1")) +
  scale_x_continuous(breaks = c(1970, 1980, 1982, 1985, 1989, 1990, 2000, 2010),
                     labels = c(1970, "", 1982, 1985, 1989, "", 2000, 2010)) +
  theme_classic(base_size = 14) +
  labs(x = "", y = "") +
  theme(legend.position = "none") +
  ggsave(file.path(loc_result_sigma, "k_Theta_log_detrend.png"), width = scale_graph*5,
         height = scale_graph*5/2)

```

This is an example of the regressions when I break the sample in 1985. It seems that there are two regimes. There are three main potential breaks around the years 1982, 1985 and 1989. 

```{r Break Year - Max k , echo = FALSE}

# Find the max of the red curve
df.fr %>% 
  subset(k.avh_log_detrend == max(k.avh_log_detrend) | 
           THETA1_log_detrend == max(THETA1_log_detrend) |
           THETA1_log_detrend == min(THETA1_log_detrend))

```

However, the break may have occur during the 80's. I have to determine which year optimize the split. To do so, I use a grid-search approach between 1980 and 1990. Below is the baseline regression leading to an elasticity of 1.356.


```{r Break Year - Baseline Regression, echo = FALSE}
# Baseline estimate
ols_base.detrend = df.fr %>% 
  lm(THETA1_log_detrend ~ k.avh_log_detrend -1, data = .)
summary(ols_base.detrend)

```

```{r Break Year - Plot regimes, echo = FALSE}

df.fr %>% 
  select(Year, k.avh_log_detrend, THETA1_log_detrend) %>% 
  mutate(before_break = as.factor(ifelse(Year <= 1985, "1970-1985", "1986-2010"))) %>% 
  
  ggplot(aes(x = k.avh_log_detrend, y = THETA1_log_detrend, color = before_break)) +
  geom_point() +
  stat_smooth(method = "lm", alpha = 0.2) +
  # stat_smooth(method = "lm", color = "black") +
  scale_color_manual(name = "", values = brewer.pal(8, "Set1")[c(3,4)]) +
  theme_classic(base_size = 14) +
  labs(x = "", y = "") +
  theme(legend.direction = "vertical", legend.box = "horizontal", 
          legend.position = c(0.02,1), legend.justification = c(0,1)) +
  ggsave(file.path(loc_result_sigma, "k_Theta_log_reg85.png"), width = scale_graph*5, height = scale_graph*5/2)

```

```{r Break Year - Optimal Splitter, echo = FALSE}

split.coef = data.frame(matrix(nrow = 0, ncol = 6))
split.R2 = data.frame(matrix(nrow = 0, ncol = 2))

# Loop to analysis splitters
for(splitter in c(1975:1995)){
  
  est_sigma.fr = df.fr %>% 
    mutate(after_split = ifelse(Year > splitter, 1, 0),
           before_split = ifelse(Year <= splitter, 1, 0))
  
  # Break
  ols.france_dummy = est_sigma.fr %>% 
    lm(THETA1_log_detrend ~ k.avh_log_detrend*before_split + k.avh_log_detrend*after_split - 1 -
         k.avh_log_detrend, data = .)
  ols.france_dummy = summary(ols.france_dummy)
  
  ## Gather results
  # Coefs
  split.coef = split.coef %>%
    rbind(data.frame(splitter,
                     var = ols.france_dummy$coefficients %>% row.names(),
                     ols.france_dummy$coefficients,
                     row.names = NULL))
  # R^2
  split.R2 = split.R2 %>% 
    rbind(data.frame(splitter, R2 = ols.france_dummy$r.squared))
  
}

# Sort data
split.coef = split.coef %>% 
  setNames(c("splitter", "variable", "estimate", "se", "tvalue", "pvalue")) %>% 
  mutate(star = ifelse(pvalue > 0.1, NA,
                       ifelse(pvalue > 0.05, "*",
                              ifelse(pvalue > 0.01, "**", "***"))))

# Display
split.coef[3:6] = split.coef[3:6] %>% apply(., 2, function(x){round(x, digits = 3)})
split.coef

split.R2$R2 = split.R2$R2 %>% round(digits = 3)
split.R2

```


```{r Estimation for the Break Year, echo = FALSE}

# Max R2 : define the break_year
break_year = split.R2 %>% subset(R2 == max(R2)) %>% pull("splitter")
print(paste0("Break in the regime in : ", break_year))


### With BTC
## Before
ols.fr.btc_before = df.fr %>% 
  subset(Year <= break_year) %>% 
  lm(formula = THETA1_log ~ k.avh_log + t_diff)

ols.fr.btc_before %>% summary()

sigma.fr.btc_before = 1/(1+ols.fr.btc_before$coefficients[2]) %>% unname()
sigma.fr.btc_before

## After
ols.fr.btc_after = df.fr %>% 
  subset(Year > break_year) %>% 
  lm(formula = THETA1_log ~ k.avh_log + t_diff)

ols.fr.btc_after %>% summary()

sigma.fr.btc_after = 1/(1+ols.fr.btc_after$coefficients[2]) %>% unname()
sigma.fr.btc_after

### Without BTC
ols.fr_before = df.fr %>% 
  subset(Year <= break_year) %>% 
  lm(formula = THETA1_log ~ k.avh_log)

ols.fr_before %>% summary()

sigma.fr_before = 1/(1+ols.fr_before$coefficients[2]) %>% unname()
sigma.fr_before

## After
ols.fr_after = df.fr %>% 
  subset(Year > break_year) %>% 
  lm(formula = THETA1_log ~ k.avh_log)

ols.fr_after %>% summary()

sigma.fr_after = 1/(1+ols.fr_after$coefficients[2]) %>% unname()
sigma.fr_after


```































