---
title: "Capital-Labor elasticity of substitution"	
author: "Fabien Petit"	
date: "24/05/2019"	
output:	
  github_document:	
    pandoc_args: --webtex
---

```{r Init, include = FALSE}	

# Define required packages
require(dplyr) # The FAMOUS one
require(reshape2) # Reshape data frame
require(ggplot2) # Plot
require(bucky) # Robust standard errors
require(sandwich)

# Define paths
loc_final = file.path("data", "final")

# Define country set
# country_set = c("Australia", "Canada", "France", "Italy", "Japan", "United States")
country_set = c("France", "United States")

```	

## Methodology

I estimate the elasticity of substitution between capital and labor using the methodology of **Leon-Ledesma, McAdam & Willman (2013)**. Estimation are done for France and United States between 1970 and 2010, using Penn World Table 9.1 data.

Following the methodology of Leon-Ledesma, McAdam & Willman (2013), I estimate the following equation :	
<center>
$$\ln k_t = \alpha - \frac{\sigma}{1-\sigma} \ln \Theta_t + \left( a_L-a_K\right)t + \varepsilon_t$$
</center>
Therefore, I need to compute the capital-to-labor ratio $~k_t~$ and the capital-to-labor income ratio $~\Theta_t~$.

## Data

```{r Load PWT data}	

pwt = read.csv(file.path(loc_final, "pwt.csv"), header = TRUE) %>%
  subset(Country %in% country_set &
           Year %in% c(1970:2010) & i_labsh2 == 1) %>%
  select("Country", "Year", "pop", "emp", "avh", "rnna", "lab_sh1", "lab_sh2")

head(pwt)
 
```	

The variables from the **Penn World Table 9.1** are the following :	

* *pop* : Population (in millions.)	
* *emp* : Number of persons engaged (in millions)	
* *avh* : Average annual hours worked by persons engaged	
* *rnna* : Capital stock at constant 2011 national prices (in mil. 2011US$)	
* *lab_sh1* : Share of labour compensation in GDP at current national prices (**Adjustment method 1**)
* *lab_sh2* : Share of labour compensation in GDP at current national prices (**Adjustment method 2**)

```{r Compare both labor share, echo = FALSE}

pwt %>% select(Country, Year, lab_sh1, lab_sh2) %>% 
  melt(id.vars = c("Country", "Year")) %>% 
  ggplot(aes(x = Year, y = value, color = variable)) +
  scale_color_discrete(name = "Adjustment Method", breaks = c("lab_sh1", "lab_sh2"),
                       labels = c("1st", "2nd")) +
  geom_line(size = 0.5) +
  facet_wrap(Country ~ .) +
  labs(x = "Year", y = "Labor share") +
  theme_classic() +
  theme(legend.direction = "horizontal", legend.position = "bottom")


```


I use the first adjustment method (see **Frenstra, Inklaar and Timmer 2015** and **Gollin 2002** for more details). An adjustment method is required to take into account self-employed income.

**Adjustment 1** adds mixed income (MIX) to the compensation of employees (COMP). Thus,
<center>
$$LS = \frac{COMP+MIX}{GDP}$$
</center>

**Adjustment 2** assumes the same labor share for mixed income as for the rest of the economy. Thus,
<center>
$$LS = \frac{COMP}{GDP-MIX}$$
</center>

In the model, workers are only young individuals and provide only labor supply. Therefore, I assume that self-employed people earn an income that is characterized as a compensation. Hence, I will use the first adjustment method.

```{r Variable computation, echo = FALSE}

# Capital in the economy (K)	
pwt$K = pwt$rnna * 1000
# Capital in the economy (K) // Corrected for hours worked	
pwt$K.avh_correct = pwt$rnna * 1000 / pwt$avh

# Labor in the economy (L)
pwt$L = pwt$emp * 1000

# Capital-to-labor ratio (k)	
pwt$k = pwt$K / pwt$L
# Capital-to-labor ratio (k) // Corrected for hours workers	
pwt$k.avh_correct = pwt$K.avh_correct / pwt$L

# Capital-to-labor income ratio (THETA) // 1st Adjustment method
pwt$THETA1 = (1-pwt$lab_sh1)/pwt$lab_sh1

# Capital-to-labor income ratio (THETA) // 2nd Adjustment method
pwt$THETA2 = (1-pwt$lab_sh2)/pwt$lab_sh2

```

I normalize the capital-to-labor ratio to the initial year (i.e. 1970).

```{r Normalization, echo = FALSE}

# Normalize to initial year
pwt = pwt %>%
  group_by(Country) %>%
  mutate(K_nor = K / first(K),
         K_nor.avh_correct = K.avh_correct / first(K.avh_correct),
         L_nor = L / first(L),
         k_nor = k / first(k),
         k_nor.avh_correct = k.avh_correct / first(k.avh_correct)) %>%
  ungroup()

```	


```{r Plot k_nor, echo = FALSE}

pwt %>% select("Country", "Year", "k_nor", "k_nor.avh_correct") %>%
  melt(id.vars = c("Country", "Year")) %>%
  ggplot(aes(x = Year, y = value, color = variable)) +
  geom_line(size = .5) +
  facet_wrap(Country ~ .) +
  scale_color_discrete(name = "", breaks = c("k_nor", "k_nor.avh_correct"),
                       labels = c("Standard", "AVH correction")) +
  labs(x = "Year", y = "Normalized capital-to-labor ratio (1970 = 1)") +
  theme_classic(base_size = 14) +
  theme(legend.direction = "horizontal", legend.position = "bottom")
  
```	

```{r Log variables, echo = FALSE}

# Variable modification for estimation	
pwt = pwt %>%
  group_by(Country) %>%
  mutate(k_nor_log = log(k_nor),
         k_nor_log.avh_correct = log(k_nor.avh_correct),
         THETA1_log_neg = -log(THETA1),
         THETA2_log_neg = -log(THETA2),
         t = Year - first(Year) +1) %>%
  ungroup()

# Plot logs

pwt %>% select("Country", "Year", "k_nor_log", "k_nor_log.avh_correct",
               "THETA1_log_neg", "THETA2_log_neg") %>%
  melt(id.vars = c("Country", "Year")) %>% 
  mutate(kap = ifelse(grepl("k", variable), "k", "theta"),
         best = ifelse(grepl("THETA1|avh", variable), "first", "second" )) %>% 
  ggplot(aes(x = Year, y = value, color = kap, linetype =  best)) +
  geom_line(size = .5) +
  facet_wrap(Country ~ .) +
  scale_color_discrete(name = "", breaks = c("k", "theta"),
                       labels = c("Normalized capital-labor ratio (log)",
                                  "Labor-capital income ratio (log)")) +
  scale_linetype_discrete(name = "", breaks = c("first", "second"),
                          labels = c("Adjustment method 1 or AVH control",
                                     "Adjustment method 2 or no control")) +
  labs(x = "Year", y = "") +
  theme_classic(base_size = 14) +
  theme(legend.direction = "vertical", legend.position = "top")
  

```

## Estimation

I estimate four versions of the elasticity of substitution :

* Without any control
* Control for biased technical change (BTC)
* Control for average hours worked (AVH)
* Control for BTC and AVH

### No controls

```{r Regression - pwt.no}

## THETA 1

# Regression : no control
ols1.no = pwt %>%
  lm(formula = k_nor_log ~ Country + THETA1_log_neg*Country - THETA1_log_neg)
# Robust standard errors
ols1.no = robustify(ols1.no) %>% 
  summary()
# Compute the associated sigma
pwt1.no = 1/(1 + ols1.no$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols1.no

## THETA 2

# Regression : no control
ols2.no = pwt %>%
  lm(formula = k_nor_log ~ Country + THETA2_log_neg*Country - THETA2_log_neg)
# Robust standard errors
ols2.no = robustify(ols2.no) %>% 
  summary()
# Compute the associated sigma
pwt2.no = 1/(1 + ols2.no$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols2.no

```

### BTC control

```{r Regression - pwt.btc}

## THETA 1

# Regression : control only for biased technical change
ols1.btc = pwt %>%
  lm(formula = k_nor_log ~ Country + THETA1_log_neg*Country + Country*t - THETA1_log_neg - t)
# Robust standard errors
ols1.btc = robustify(ols1.btc) %>%
  summary()
# Compute the associated sigma
pwt1.btc = 1/(1 + ols1.btc$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols1.btc

## THETA 2

# Regression : control only for biased technical change
ols2.btc = pwt %>%
  lm(formula = k_nor_log ~ Country + THETA2_log_neg*Country + Country*t - THETA2_log_neg - t)
# Robust standard errors
ols2.btc = robustify(ols2.btc) %>%
  summary()
# Compute the associated sigma
pwt2.btc = 1/(1 + ols2.btc$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols2.btc

```

### AVH control

```{r Regression - pwt1.avh}

## THETA 1

# Regression : control only for hours worked
ols1.avh = pwt %>%
  lm(formula = k_nor_log.avh_correct ~ Country + THETA1_log_neg*Country - THETA1_log_neg)
# Robust standard errors
ols1.avh = robustify(ols1.avh) %>% 
  summary()
# Compute the associated sigma
pwt1.avh = 1/(1 + ols1.avh$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols1.avh

## THETA 2

# Regression : control only for hours worked
ols2.avh = pwt %>%
  lm(formula = k_nor_log.avh_correct ~ Country + THETA2_log_neg*Country - THETA2_log_neg)
# Robust standard errors
ols2.avh = robustify(ols2.avh) %>% 
  summary()
# Compute the associated sigma
pwt2.avh = 1/(1 + ols2.avh$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols2.avh

```

### AVH/BTC controls

```{r Regression - pwt1.avh.btc}

## THETA 1

# Regression : control for both hours worked and biased technical change
ols1.avh.btc = pwt %>%
  lm(formula = k_nor_log.avh_correct ~ Country + THETA1_log_neg*Country + t*Country - THETA1_log_neg - t)
# Robust standard errors
ols1.avh.btc = robustify(ols1.avh.btc) %>% 
  summary()
# Compute the associated sigma
pwt1.avh.btc = 1/(1 + ols1.avh.btc$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols1.avh.btc

## THETA 2

# Regression : control for both hours worked and biased technical change
ols2.avh.btc = pwt %>%
  lm(formula = k_nor_log.avh_correct ~ Country + THETA2_log_neg*Country + t*Country - THETA2_log_neg - t)
# Robust standard errors
ols2.avh.btc = robustify(ols2.avh.btc) %>% 
  summary()
# Compute the associated sigma
pwt2.avh.btc = 1/(1 + ols2.avh.btc$coefficients[c((length(country_set)+1):(2*length(country_set)))])
# Visualize summary
ols2.avh.btc

```	

### Summary of the results

I gather all estimated $\hat{\sigma}$. Without control for biased technical change (BTC), I obtain negative $\hat{\sigma}$, which is not possible. Once I control for BTC, I obtain a positive elasticity without control on the average hours worked (AVH). United States elasticity is below one but not significantly different from 1. This case is the Cobb-Douglas specification. However, without correcting by hours worked I generate a bias toward Cobb-Douglas for both countries. Finally, on the last estimate, with BTC and AVH controls, I obtain a capital-labor elasticity of substitution of 1.356 for France and 1.224 for United States (see table below).
With the second adjustment method, estimates are still biased toward 1 when I do not control for AVH. However, once done, the elasticity is close to 1 for France (i.e. 1.047) and larger for the US (i.e. 1.329).

```{r PWT - Gather sigma, echo = FALSE}

# Regroup all estimated sigma
pwt_est = data.frame("Country" = country_set, pwt1.no, pwt1.btc, pwt1.avh, pwt1.avh.btc,
                     pwt2.no, pwt2.btc, pwt2.avh, pwt2.avh.btc) %>%
  melt(id.vars = "Country") %>%
  mutate(btc = ifelse(grepl(pattern = "btc", variable), 1, 0),
         avh = ifelse(grepl(pattern = "avh", variable), 1, 0),
         adj = ifelse(grepl(pattern = "1", variable), 1, 2),
         data = "pwt") %>%
  select("Country", "data", "btc", "avh", "adj", "value")

# Visualization
pwt_est

```	

